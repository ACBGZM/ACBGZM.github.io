<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="miu"><meta name="copyright" content="miu"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>machine learning - andrew ng | 临时个人主页</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script type="module">import { renderKatex } from '/js/utils.js'
document.addEventListener("DOMContentLoaded", () => {
  renderKatex({
    ...{},
    ...true?.options,
  });
});</script><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"acbgzm.github.io","root":"/","title":"slowmotion","version":"1.10.9","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"/data/sentences.json"},"local_search":{"path":"/search.xml"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="学习吴恩达老师coursera《机器学习》网课的笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="machine learning - andrew ng">
<meta property="og:url" content="http://acbgzm.github.io/2021/03/25/ml2014ang/index.html">
<meta property="og:site_name" content="临时个人主页">
<meta property="og:description" content="学习吴恩达老师coursera《机器学习》网课的笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/1.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/2.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/3.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/4.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/5.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/6.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/7.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/8.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/9.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/10.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/11.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/12.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/13.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/14.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/15.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/16.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/17.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/18.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/19.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/20.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/21.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/22.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/23.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/24.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/25.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/26.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/27.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/28.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/29.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/30.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/31.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/32.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/33.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/34.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/35.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/36.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/37.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/38.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/39.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/40.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/41.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/42.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/43.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/44.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/45.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/46.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/47.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/48.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/49.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/50.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/51.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/52.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/53.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/54.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/55.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/56.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/57.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/58.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/59.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/60.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/61.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/62.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/63.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/64.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/65.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/66.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/67.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/68.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/69.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/70.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/71.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/72.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/73.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/74.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/75.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/76.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/77.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/78.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/79.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/80.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/81.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/82.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/83.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/84.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/85.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/86.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/87.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/88.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/89.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/90.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/91.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/92.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/93.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/94.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/95.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/96.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/97.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/98.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/99.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/100.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/101.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/102.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/103.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/104.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/105.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/106.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/107.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/108.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/109.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/110.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/111.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/112.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/112.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/114.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/115.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/116.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/117.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/118.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/119.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/120.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/121.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/122.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/123.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/124.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/125.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/126.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/127.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/128.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/129.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/130.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/131.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/132.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/133.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/134.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/135.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/136.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/137.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/138.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/139.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/140.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/141.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/142.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/143.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/144.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/145.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/146.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/147.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/148.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/149.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/150.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/151.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/152.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/153.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/154.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/155.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/156.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/157.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/158.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/159.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/160.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/161.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/162.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/163.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/164.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/165.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/166.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/167.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/168.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/169.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/170.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/171.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/172.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/173.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/174.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/175.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/176.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/177.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/178.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/179.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/180.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/181.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/182.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/183.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/184.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/185.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/186.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/187.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/188.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/189.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/190.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/191.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/192.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/193.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/194.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/195.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/196.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/197.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/198.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/199.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/200.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/201.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/203.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/202.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/204.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/205.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/206.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/207.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/208.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/209.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/210.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/211.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/212.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/213.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/214.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/215.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/216.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/217.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/218.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/219.png">
<meta property="article:published_time" content="2021-03-25T06:01:30.000Z">
<meta property="article:modified_time" content="2022-03-05T06:59:55.352Z">
<meta property="article:author" content="miu">
<meta property="article:tag" content="机器学习">
<meta property="article:tag" content="课程笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/1.jpg"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="miu"><img width="96" loading="lazy" src="/images/avatar.png" alt="miu"><span class="site-author-status" title="永远相信美好的事情即将发生">🎸</span></a><div class="site-author-name"><a href="/about/">miu</a></div><span class="site-name">临时个人主页</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">6</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">13</span></a></div><a class="site-state-item hty-icon-button" href="/lab" title="lab"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ACBGZM" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/10388034" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:ACBGZM@126.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="友链" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:open-arm-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%A8%80"><span class="toc-text">第一章 引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%AC%A2%E8%BF%8E"><span class="toc-text">1-1 欢迎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-What-is-ML"><span class="toc-text">1-2 What is ML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-text">1-3 监督学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-text">1-4 无监督学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%88Linear-Regression-with-One-Variable%EF%BC%89"><span class="toc-text">第二章 单变量线性回归（Linear Regression with One Variable）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-regression%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="toc-text">2-1 regression模型描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%EF%BC%88cost-function%EF%BC%89"><span class="toc-text">2-2 代价函数（cost function）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3I"><span class="toc-text">2-3 代价函数的直观理解I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3II"><span class="toc-text">2-4 代价函数的直观理解II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88gradient-descent%EF%BC%89"><span class="toc-text">2-5 梯度下降（gradient descent）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%9A%84%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3"><span class="toc-text">2-6  梯度下降的直观理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-text">2-7 线性回归的梯度下降</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="toc-text">第三章 线性代数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F"><span class="toc-text">3-1 矩阵和向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8A%A0%E6%B3%95%E5%92%8C%E6%A0%87%E9%87%8F%E4%B9%98%E6%B3%95"><span class="toc-text">3-2 加法和标量乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%90%91%E9%87%8F%E7%9B%B8%E4%B9%98"><span class="toc-text">3-3 矩阵与向量相乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-text">3-4 矩阵乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">3-5 矩阵乘法的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E9%80%86%E3%80%81%E8%BD%AC%E7%BD%AE"><span class="toc-text">3-6 逆、转置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%88Linear-Regression-with-Multiple-Variables%EF%BC%89"><span class="toc-text">第四章 多变量线性回归（Linear Regression with Multiple Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%A4%9A%E7%BB%B4%E7%89%B9%E5%BE%81"><span class="toc-text">4-1 多维特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%A4%9A%E5%8F%98%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-text">4.2 多变量梯度下降</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%8A%80%E5%B7%A71-%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE"><span class="toc-text">4.3 梯度下降技巧1-特征缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%8A%80%E5%B7%A72-%E5%AD%A6%E4%B9%A0%E7%8E%87"><span class="toc-text">4.4 梯度下降技巧2-学习率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92%EF%BC%88polynomial-regression%EF%BC%89"><span class="toc-text">4.5 选择合适的特征和多项式回归（polynomial regression）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B"><span class="toc-text">4.6 正规方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B%E5%8F%8A%E4%B8%8D%E5%8F%AF%E9%80%86%E6%80%A7"><span class="toc-text">4.7 *正规方程及不可逆性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-Octave-Tutorial"><span class="toc-text">第五章 Octave Tutorial</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%90%91%E9%87%8F%E5%8C%96"><span class="toc-text">5.6 向量化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%88Logistic-Regression%EF%BC%89"><span class="toc-text">第六章 逻辑回归（Logistic Regression）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%88classification%EF%BC%89"><span class="toc-text">6.1 分类问题（classification）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%81%87%E8%AE%BE%E8%A1%A8%E7%A4%BA%EF%BC%88hypothesis-representation%EF%BC%89"><span class="toc-text">6.2 假设表示（hypothesis representation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%88%A4%E5%AE%9A%E8%BE%B9%E7%95%8C%EF%BC%88decision-boundary%EF%BC%89"><span class="toc-text">6.3 判定边界（decision boundary）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%EF%BC%88cost-function%EF%BC%89"><span class="toc-text">6.4 代价函数（cost function）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E7%AE%80%E5%8C%96%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E5%92%8C%E5%BA%94%E7%94%A8%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-text">6.5 简化代价函数和应用梯度下降</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E9%AB%98%E7%BA%A7%E4%BC%98%E5%8C%96"><span class="toc-text">6.6 高级优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%88multi-class-classification%EF%BC%89"><span class="toc-text">6.7 多分类问题：一对多（multi-class classification）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%AD%A3%E5%88%99%E5%8C%96%EF%BC%88Regularization%EF%BC%89"><span class="toc-text">第七章 正则化（Regularization）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98%EF%BC%88overfitting%EF%BC%89"><span class="toc-text">7.1 过拟合问题（overfitting）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E3%80%81%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%EF%BC%88cost-function%EF%BC%89"><span class="toc-text">7.2 正则化的直观理解、代价函数（cost function）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">正则化的直观理解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95"><span class="toc-text">具体方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%EF%BC%88regularized-linear-regression%EF%BC%89"><span class="toc-text">7.3 线性回归的正则化（regularized linear regression）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-text">梯度下降</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B"><span class="toc-text">正规方程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%EF%BC%88regularized-logistic-regression%EF%BC%89"><span class="toc-text">7.4 逻辑回归的正则化（regularized logistic regression）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%A1%A8%E8%BF%B0%EF%BC%88Neural-Networks-Representation%EF%BC%89"><span class="toc-text">第八章 神经网络：表述（Neural Networks: Representation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%81%87%E8%AE%BE"><span class="toc-text">8.1 非线性假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%A5%9E%E7%BB%8F%E5%85%83%E5%92%8C%E5%A4%A7%E8%84%91"><span class="toc-text">8.2 神经元和大脑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%A4%BA%E2%85%A0"><span class="toc-text">8.3 模型表示Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%A4%BA%E2%85%A1%EF%BC%9A%E5%90%91%E9%87%8F%E5%8C%96%E5%92%8C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD"><span class="toc-text">8.4 模型表示Ⅱ：向量化和前向传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E4%B8%BE%E4%BE%8B%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E2%85%A0"><span class="toc-text">8.5 举例直观理解Ⅰ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E4%B8%BE%E4%BE%8B%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E2%85%A1"><span class="toc-text">8.6 举例直观理解Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%88multi-class-clasification%EF%BC%89"><span class="toc-text">8.7 神经网络的多元分类问题（multi-class clasification）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88Neural-Networks-Learning%EF%BC%89"><span class="toc-text">第九章 神经网络的学习（Neural Networks: Learning）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%EF%BC%88cost-function%EF%BC%89"><span class="toc-text">9.1 代价函数（cost function）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%EF%BC%9A"><span class="toc-text">神经网络的符号表示：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">神经网络的代价函数：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%EF%BC%88backpropagation-algorithm%EF%BC%89"><span class="toc-text">9.2 反向传播算法（backpropagation algorithm）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-text">反向传播算法的整体过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3"><span class="toc-text">9.3 反向传播算法的直观理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%B1%95%E5%BC%80%E5%8F%82%E6%95%B0"><span class="toc-text">9.4 使用注意：展开参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E6%A2%AF%E5%BA%A6%E6%A3%80%E9%AA%8C%EF%BC%88gradient-checking%EF%BC%89"><span class="toc-text">9.5 梯度检验（gradient checking）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E4%BC%B0%E7%AE%97%E5%AF%BC%E6%95%B0"><span class="toc-text">第一步：估算导数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AF%B9%E6%AF%94%E4%BC%B0%E7%AE%97%E5%80%BC%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">第二步：对比估算值和反向传播的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">总体实现过程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E9%9A%8F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88random-initialization%EF%BC%89"><span class="toc-text">9.6 随机初始化（random initialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%E7%BB%84%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="toc-text">9.7 组合起来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-text">训练神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="toc-text">确定一个网络结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">需要实现的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3"><span class="toc-text">直观理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6"><span class="toc-text">9.8 无人驾驶</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BB%BA%E8%AE%AE-Advice-for-Applying-Machine-Learning"><span class="toc-text">第十章 应用机器学习的建议(Advice for Applying Machine Learning)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%86%B3%E5%AE%9A%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">10.1 决定下一步做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%AA%E5%81%87%E8%AE%BE"><span class="toc-text">10.2 评估一个假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E5%92%8C%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E9%9B%86"><span class="toc-text">10.3 模型选择和交叉验证集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E2%85%A0"><span class="toc-text">模型选择Ⅰ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E9%9B%86"><span class="toc-text">交叉验证集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E2%85%A1"><span class="toc-text">模型选择Ⅱ</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E8%AF%8A%E6%96%AD%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE%EF%BC%88diagnosing-bias-vs-variance%EF%BC%89"><span class="toc-text">10.4 诊断偏差和方差（diagnosing bias vs. variance）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BD%95%E8%A1%A8%E7%8E%B0%E4%B8%8D%E4%BD%B3%EF%BC%9F"><span class="toc-text">如何确定模型为何表现不佳？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E6%AD%A3%E5%88%99%E5%8C%96%E5%92%8C%E5%81%8F%E5%B7%AE-x2F-%E6%96%B9%E5%B7%AE"><span class="toc-text">10.5  正则化和偏差&#x2F;方差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-%E8%AF%8A%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%9A%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF%EF%BC%88learning-curves%EF%BC%89"><span class="toc-text">10.6 诊断方法：学习曲线（learning curves）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-%E5%86%B3%E5%AE%9A%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">10.7 决定下一步做什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%9F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-text">跟神经网络的结合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-Machine-Learning-System-Design"><span class="toc-text">第十一章 机器学习系统设计(Machine Learning System Design)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E7%A1%AE%E5%AE%9A%E4%BC%98%E5%85%88%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-text">11.1 确定优先执行的事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90%EF%BC%88error-analysis%EF%BC%89"><span class="toc-text">11.2 误差分析（error analysis）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90"><span class="toc-text">误差分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E5%8C%96%E6%8C%87%E6%A0%87"><span class="toc-text">量化指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E7%B1%BB%E5%81%8F%E6%96%9C%E7%9A%84%E8%AF%AF%E5%B7%AE%E5%BA%A6%E9%87%8F%EF%BC%88error-metrics-for-skewed-classes%EF%BC%89"><span class="toc-text">11.3 类偏斜的误差度量（error metrics for skewed classes）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E6%9F%A5%E5%87%86%E7%8E%87%E5%92%8C%E6%9F%A5%E5%85%A8%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9D%83%E8%A1%A1%EF%BC%88trading-off-precision-and-recall%EF%BC%89"><span class="toc-text">11.4 查准率和查全率之间的权衡（trading off precision and recall）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">11.5 机器学习的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-Support-Vector-Machines%EF%BC%89"><span class="toc-text">第十二章 支持向量机(Support Vector Machines）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87%EF%BC%88optimization-objective%EF%BC%89"><span class="toc-text">12.1 优化目标（optimization objective）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89SVM%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-text">从逻辑回归的损失函数定义SVM的损失函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%A4%A7%E8%BE%B9%E7%95%8C%E7%9A%84%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%EF%BC%88large-margin-intuition%EF%BC%89"><span class="toc-text">12.2 大边界的直观理解（large margin intuition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E5%A4%A7%E8%BE%B9%E7%95%8C%E5%88%86%E7%B1%BB%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86"><span class="toc-text">12.3 大边界分类器背后的数学原理*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E6%A0%B8%E5%87%BD%E6%95%B0%E2%85%A0"><span class="toc-text">12.4 核函数Ⅰ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">是否有更好的特征选择方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%89%B9%E5%BE%81%E5%88%B0%E9%A2%84%E6%B5%8B%E5%87%BD%E6%95%B0"><span class="toc-text">从特征到预测函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E6%A0%B8%E5%87%BD%E6%95%B0%E2%85%A1"><span class="toc-text">12.5 核函数Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-landmarks%EF%BC%9F"><span class="toc-text">如何选择 landmarks？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVM-%E7%9A%84%E8%AE%AD%E7%BB%83"><span class="toc-text">SVM 的训练</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVM-%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE"><span class="toc-text">SVM 的参数，偏差和方差</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E4%BD%BF%E7%94%A8%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-text">12.6 使用支持向量机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E8%81%9A%E7%B1%BB-Clustering%EF%BC%89"><span class="toc-text">第十三章 聚类(Clustering）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%EF%BC%88unsupervised-learning-introduction%EF%BC%89"><span class="toc-text">13.1 无监督学习简介（unsupervised learning introduction）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-K%E5%9D%87%E5%80%BC%E7%AE%97%E6%B3%95%EF%BC%88K-means-algorithm%EF%BC%89"><span class="toc-text">13.2 K均值算法（K-means algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87%EF%BC%88optimization-objective%EF%BC%89"><span class="toc-text">13.3 优化目标（optimization objective）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E9%9A%8F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88random-initialization%EF%BC%89"><span class="toc-text">13.4 随机初始化（random initialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-%E9%80%89%E6%8B%A9%E8%81%9A%E7%B1%BB%E4%B8%AA%E6%95%B0K%EF%BC%88choosing-the-number-of-clusters%EF%BC%89"><span class="toc-text">13.5 选择聚类个数K（choosing the number of clusters）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%99%8D%E7%BB%B4-Dimensionality-Reduction%EF%BC%89"><span class="toc-text">第十四章 降维(Dimensionality Reduction）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E5%8A%A8%E6%9C%BA%E4%B8%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%EF%BC%88data-compression%EF%BC%89"><span class="toc-text">14.1 动机一：数据压缩（data compression）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E5%8A%A8%E6%9C%BA%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%EF%BC%88data-visualization%EF%BC%89"><span class="toc-text">14.2 动机二：数据可视化（data visualization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%EF%BC%88principal-component-analysis-problem-formulation%EF%BC%89"><span class="toc-text">14.3 主成分分析问题（principal component analysis problem formulation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PCA"><span class="toc-text">PCA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCA%E5%92%8C%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">PCA和线性回归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88principal-component-analysis-algorithm%EF%BC%89"><span class="toc-text">14.4 主成分分析算法（principal component analysis algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E9%80%89%E6%8B%A9%E4%B8%BB%E6%88%90%E5%88%86%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%88choosing-the-number-of-principal-components%EF%BC%89"><span class="toc-text">14.5 选择主成分的数量（choosing the number of  principal components）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E9%99%8D%E7%BB%B4%E9%87%8D%E5%BB%BA%EF%BC%88reconstruction-from-compressed-representation%EF%BC%89"><span class="toc-text">14.6 降维重建（reconstruction from compressed representation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E5%BB%BA%E8%AE%AE%EF%BC%88advice-for-applying-PCA%EF%BC%89"><span class="toc-text">14.7 主成分分析法的应用建议（advice for applying PCA）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8PCA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">应用PCA的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCA%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">PCA的应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B-Anomaly-Detection%EF%BC%89"><span class="toc-text">第十五章 异常检测(Anomaly Detection）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%A8%E6%9C%BA%EF%BC%88problem-motivation%EF%BC%89"><span class="toc-text">15.1 问题的动机（problem motivation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%EF%BC%88gaussian-distribution%EF%BC%89"><span class="toc-text">15.2 高斯分布（gaussian distribution）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="toc-text">高斯分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="toc-text">参数估计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88algorithm%EF%BC%89"><span class="toc-text">15.3 异常检测算法（algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E5%BC%80%E5%8F%91%E5%92%8C%E8%AF%84%E4%BB%B7%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%88developing-and-evaluating-an-anomaly-detection-system%EF%BC%89"><span class="toc-text">15.4 开发和评价一个异常检测系统（developing and evaluating an anomaly detection system）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%AF%B9%E6%AF%94%EF%BC%88anomaly-detection-vs-supervised-learning%EF%BC%89"><span class="toc-text">15.5 异常检测与监督学习对比（anomaly detection vs. supervised learning）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-6-%E9%80%89%E6%8B%A9%E7%89%B9%E5%BE%81%EF%BC%88choosing-what-features-to-use%EF%BC%89"><span class="toc-text">15.6 选择特征（choosing what features to use）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E7%89%B9%E5%BE%81%E5%88%86%E5%B8%83"><span class="toc-text">如何调整特征分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%89%B9%E5%BE%81"><span class="toc-text">如何选择特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-7-%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83-%EF%BC%88multivariate-gaussian-distribution%EF%BC%89"><span class="toc-text">15.7 多元高斯分布*（multivariate gaussian distribution）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8-%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B-%EF%BC%88anomaly-detection-using-the-multivariate-gaussian-distribution%EF%BC%89"><span class="toc-text">15.8 使用多元高斯分布进行异常检测*（anomaly detection using the multivariate gaussian distribution）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%85%AC%E5%BC%8F"><span class="toc-text">步骤和公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">多元高斯分布模型和原始模型的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Recommender-Systems%EF%BC%89"><span class="toc-text">第十六章 推荐系统(Recommender Systems）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E9%97%AE%E9%A2%98%E8%A7%84%E5%88%92%EF%BC%88problem-formulation%EF%BC%89"><span class="toc-text">16.1 问题规划（problem formulation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%EF%BC%88content-based-recommendations%EF%BC%89"><span class="toc-text">16.2 基于内容的推荐算法（content-based recommendations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%EF%BC%88collaborative-filtering%EF%BC%89"><span class="toc-text">16.3 协同过滤（collaborative filtering）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%EF%BC%88collaborative-filtering-algorithm%EF%BC%89"><span class="toc-text">16.4 协同过滤算法（collaborative filtering algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-%E5%90%91%E9%87%8F%E5%8C%96%EF%BC%9A%E4%BD%8E%E7%A7%A9%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%EF%BC%88vectorization-low-rank-matrix-factorization%EF%BC%89"><span class="toc-text">16.5 向量化：低秩矩阵分解（vectorization : low rank matrix factorization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%9A%E5%9D%87%E5%80%BC%E5%BD%92%E4%B8%80%E5%8C%96%EF%BC%88implementational-detail-mean-normalization%EF%BC%89"><span class="toc-text">16.6 实现细节：均值归一化（implementational detail : mean normalization）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Large-Scale-Machine-Learning%EF%BC%89"><span class="toc-text">第十七章 大规模机器学习(Large Scale Machine Learning）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88learning-with-large-datasets%EF%BC%89"><span class="toc-text">17.1 大型数据集的学习（learning with large datasets）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88stochastic-gradient-descent%EF%BC%89"><span class="toc-text">17.2 随机梯度下降（stochastic gradient descent）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88mini-batch-gradient-descent%EF%BC%89"><span class="toc-text">17.3 小批量梯度下降（mini-batch gradient descent）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%94%B6%E6%95%9B%EF%BC%88stochastic-gradient-descent-convergence%EF%BC%89"><span class="toc-text">17.4 随机梯度下降收敛（stochastic gradient descent convergence）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%EF%BC%88online-learning%EF%BC%89"><span class="toc-text">17.5 在线学习（online learning）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-6-%E6%98%A0%E5%B0%84%E5%8C%96%E7%AE%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%EF%BC%88map-reduce-and-data-parallelism%EF%BC%89"><span class="toc-text">17.6 映射化简和数据并行（map-reduce and data parallelism）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB-Application-example-Photo-OCR%EF%BC%89"><span class="toc-text">第十八章 应用实例：图片文字识别(Application example : Photo OCR）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%B5%81%E7%A8%8B%EF%BC%88problem-description-and-pipeline%EF%BC%89"><span class="toc-text">18.1 问题描述和流程（problem description and pipeline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88sliding-windows%EF%BC%89"><span class="toc-text">18.2 滑动窗口（sliding windows）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pipeline%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%A3%80%E6%B5%8B%E6%96%87%E5%AD%97%E5%8C%BA%E5%9F%9F"><span class="toc-text">pipeline第一步：检测文字区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pipeline%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AD%97%E6%AF%8D%E5%88%86%E5%89%B2"><span class="toc-text">pipeline第二步：字母分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pipeline%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%AD%97%E6%AF%8D%E8%AF%86%E5%88%AB"><span class="toc-text">pipeline第三步：字母识别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-%E8%8E%B7%E5%8F%96%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BA%BA%E5%B7%A5%E6%95%B0%E6%8D%AE%E5%90%88%E6%88%90%EF%BC%88getting-lots-of-data-artificial-data-synthesis%EF%BC%89"><span class="toc-text">18.3 获取大量数据和人工数据合成（getting lots of data : artificial data synthesis）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%B8%80%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%BA%A7%E7%94%9F%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-text">其一：从零开始产生数据集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%B7%B2%E6%9C%89%E6%95%B0%E6%8D%AE%E6%89%A9%E5%85%85%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-text">从已有数据扩充数据集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-%E4%B8%8A%E9%99%90%E5%88%86%E6%9E%90%EF%BC%9A%E5%8A%B2%E5%BE%80%E4%BD%95%E5%A4%84%E4%BD%BF%EF%BC%88ceiling-analysis-what-part-of-the-pipeline-to-work-on-next%EF%BC%89"><span class="toc-text">18.4 上限分析：劲往何处使（ceiling analysis : what part of the pipeline to work on next）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E7%BB%93%E6%9D%9F-Conclusion%EF%BC%89"><span class="toc-text">第十九章 结束(Conclusion）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-%E6%80%BB%E7%BB%93%E4%B8%8E%E8%87%B4%E8%B0%A2%EF%BC%88summary-and-thank-you%EF%BC%89"><span class="toc-text">19.1 总结与致谢（summary and thank you）</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://acbgzm.github.io/2021/03/25/ml2014ang/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="miu"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="临时个人主页"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">machine learning - andrew ng</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2021-03-25 14:01:30" itemprop="dateCreated datePublished" datetime="2021-03-25T14:01:30+08:00">2021-03-25</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="本文字数">23.3k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="阅读时长">87m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray" itemprop="url" rel="index"><span itemprop="text">笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">机器学习</span></a><a class="tag-item" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">课程笔记</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><p>图片比较多，加载方法也比较笨，好在可以记忆浏览位置，如果有载图错误直接刷新即可。</p>
<p>代码笔记见 <a target="_blank" rel="noopener" href="https://github.com/ACBGZM/ml-notes/tree/master/ng-ml2014/code">此处</a> 。</p>
<h2 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h2><h3 id="1-1-欢迎"><a href="#1-1-欢迎" class="headerlink" title="1-1 欢迎"></a>1-1 欢迎</h3><p>机器学习应用：</p>
<ul>
<li>Database mining<ul>
<li><strong>large datasets</strong> from growth of automation&#x2F;web.</li>
<li>e.g., Web click data, medical records, biology, engineering</li>
</ul>
</li>
<li>Applications cannot program by hand.<ul>
<li>e.g., Autonomous helicopter, handwriting recognition, NLP, CV</li>
</ul>
</li>
<li>Self-customizing programs<ul>
<li>e.g., Amazon product recommendations</li>
</ul>
</li>
<li>Understanding human learning (brain, real AI)</li>
</ul>
<h3 id="1-2-What-is-ML"><a href="#1-2-What-is-ML" class="headerlink" title="1-2 What is ML"></a>1-2 What is ML</h3><p>经验E、任务T、度量P：<strong>机器学习是 T, measured by P, improves with E.</strong></p>
<p>ML algorithms:</p>
<ul>
<li>Supervised learning（监督学习）</li>
<li>Unsupervised learning（无监督学习）</li>
<li>Others: Reinforcement learning（强化学习）, recommender systems（推荐系统）</li>
</ul>
<h3 id="1-3-监督学习"><a href="#1-3-监督学习" class="headerlink" title="1-3 监督学习"></a>1-3 监督学习</h3><p>“right answers” given：给一个数据集，含有一部分正确答案。使用监督学习算法得到对应关系。</p>
<p>监督学习类型：</p>
<ul>
<li>regression（回归问题）：输出具体值。如估计房价</li>
<li>classification（分类问题）：输出离散值。如判断肿瘤</li>
</ul>
<p>Q：实际问题，有多个attributes和多个features，甚至无穷个，如何处理？</p>
<p>A：以支持向量机算法为例，有数学方法来处理无穷多的features。</p>
<h3 id="1-4-无监督学习"><a href="#1-4-无监督学习" class="headerlink" title="1-4 无监督学习"></a>1-4 无监督学习</h3><p>给定数据集没有label，不知道有哪些类型。使用无监督学习算法寻找数据中的结构。</p>
<p>无监督学习类型：</p>
<ul>
<li><p>使用clustering（聚类算法）来自动分簇。</p>
<p>如：新闻分簇，DNA分组；组织计算机群、社交网络分析、市场分割、天文数据分析。</p>
</li>
<li><p>Cocktail party problem，两个麦克录下两个人同时说话，将他们分离。</p>
</li>
</ul>
<h2 id="第二章-单变量线性回归（Linear-Regression-with-One-Variable）"><a href="#第二章-单变量线性回归（Linear-Regression-with-One-Variable）" class="headerlink" title="第二章 单变量线性回归（Linear Regression with One Variable）"></a>第二章 单变量线性回归（Linear Regression with One Variable）</h2><h3 id="2-1-regression模型描述"><a href="#2-1-regression模型描述" class="headerlink" title="2-1 regression模型描述"></a>2-1 regression模型描述</h3><p>训练集</p>
<ul>
<li>m &#x3D;训练样本的个数</li>
<li>x &#x3D; input variable&#x2F;features</li>
<li>y &#x3D; output variable&#x2F;features</li>
<li>(x, y) &#x3D; 一个训练样本</li>
<li>(x<sup>(i)</sup>, y<sup>(i)</sup>) &#x3D; 第i个样本</li>
</ul>
<p>机器学习算法从训练集得出函数h（hypothesis），表示从x到y的对应关系。</p>
<p>在预测房价问题上，假定h是一元一次函数。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/1.jpg' / loading="lazy">




<h3 id="2-2-代价函数（cost-function）"><a href="#2-2-代价函数（cost-function）" class="headerlink" title="2-2 代价函数（cost function）"></a>2-2 代价函数（cost function）</h3><p>现在有h函数：$h_\theta(x) &#x3D; \theta_0 + \theta_1x$，还有一个训练集。</p>
<p>我们的目的是寻找h函数中的两个参数θ<sub>0</sub>、θ<sub>1</sub>，让h<sub>θ</sub>(x)拟合实际y.</p>
<p>定义代价函数，计算h和y的差，要让其取最小，表达式如下：</p>
<p>$$minimize_{\theta_0, \theta_1}  \frac{1}{2m}\sum_{i&#x3D;1}^{m}({h_\theta(x^{(i)})-y^{(i)}})^2$$</p>
<p>也就是使代价函数  $ J({\theta_0, \theta_1}) &#x3D; \frac{1}{2m}\sum_{i&#x3D;1}^{m}({h_\theta(x^{(i)})-y^{(i)}})^2 $  取到最小值。</p>
<h3 id="2-3-代价函数的直观理解I"><a href="#2-3-代价函数的直观理解I" class="headerlink" title="2-3 代价函数的直观理解I"></a>2-3 代价函数的直观理解I</h3><ul>
<li><p>Hypothesis:		$h_\theta(x) &#x3D; \theta_0 + \theta_1x$</p>
</li>
<li><p>Parameters:		$\theta_0, \theta_1$</p>
</li>
<li><p>Cost Funcion:	 $J({\theta_0, \theta_1}) &#x3D; \frac{1}{2m}\sum_{i&#x3D;1}^{m}({h_\theta(x^{(i)})-y^{(i)}})^2$</p>
</li>
<li><p>Goal:					$minimize_{\theta_0, \theta_1} J({\theta_0, \theta_1})$</p>
</li>
</ul>
<p>取不同的θ<sub>0</sub>θ<sub>1</sub>，得到不同的h(x)，对应不同的J(θ<sub>0</sub>, θ<sub>1</sub>).</p>
<p>下图是只有一个变量的简化情况，此时可以画出一元函数 J(θ<sub>1</sub>) 的曲线。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/2.jpg' / loading="lazy">

<p>选择θ，使J的值最小化。此时h函数最好地拟合了现实情况。</p>
<h3 id="2-4-代价函数的直观理解II"><a href="#2-4-代价函数的直观理解II" class="headerlink" title="2-4 代价函数的直观理解II"></a>2-4 代价函数的直观理解II</h3><p>有两个参数时，得到 J(θ<sub>0</sub>, θ<sub>1</sub>) 的三维图像。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/3.jpg'  width="50%" height="50%"/ loading="lazy">

<p>可以用等高线图在平面上展示。中心点处函数值最小。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/4.jpg'  width="50%" height="50%"/ loading="lazy">

<p>我们希望有一个算法，来<strong>自动找到使 J 最小的参数 θ</strong> .</p>
<h3 id="2-5-梯度下降（gradient-descent）"><a href="#2-5-梯度下降（gradient-descent）" class="headerlink" title="2-5 梯度下降（gradient descent）"></a>2-5 梯度下降（gradient descent）</h3><ol>
<li><p>开始时，给θ设置初始值；</p>
</li>
<li><p>改变θ，使 J 的值减少，直到取到了局部最小值；</p>
</li>
<li><p>重复上个过程。</p>
</li>
</ol>
<p>直观解释：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/5.jpg'  width="50%" height="50%"/ loading="lazy">

<p>​		不同的初始点可能走到不同的结束点。</p>
<p>数学解释：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/6.jpg'  width="70%" height="70%"/ loading="lazy">

<p>​		α 是学习率，表示梯度下降的步幅大小。偏导数表示梯度下降的方向。</p>
<p>​		需要注意的是，要让多个 θ 同时更新。先计算多个temp值，再一起赋新值。</p>
<h3 id="2-6-梯度下降的直观理解"><a href="#2-6-梯度下降的直观理解" class="headerlink" title="2-6  梯度下降的直观理解"></a>2-6  梯度下降的直观理解</h3><p>偏导数的直观解释：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/7.jpg'  width="50%" height="50%"/ loading="lazy">

<p>​		以单个变量的函数为例。偏导数的值保证了 $\theta$ 一定朝 $J(\theta)$ 下降的方向变化。</p>
<p>学习率 α 的直观解释：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/8.jpg'  width="50%" height="50%"/ loading="lazy">

<p>​		α 太小，步数太多；α 太大，会导致无法收敛甚至发散。</p>
<p>在到达optimum点后，偏导数值为0，梯度下降算法就什么也不做了。</p>
<p>当学习率 α 不变时，梯度下降进行的过程中，偏导数通常会变小，因此每一步下降幅度会减小。</p>
<p>因此在接近局部最小值时，步子会变小。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/9.jpg'  width="50%" height="50%"/ loading="lazy">



<h3 id="2-7-线性回归的梯度下降"><a href="#2-7-线性回归的梯度下降" class="headerlink" title="2-7 线性回归的梯度下降"></a>2-7 线性回归的梯度下降</h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/10.jpg'  width="70%" height="70%"/ loading="lazy">

<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/11.jpg'  width="70%" height="70%"/ loading="lazy">

<p>这个梯度下降算法称为 <strong>batch</strong> 梯度下降。</p>
<p>​		原因是：每一步梯度下降，都计算了<strong>整个训练集m个样本</strong>的插值平方总和。</p>
<p>​		也有方法不全览整个训练集，每次只关注小子集。这将在之后介绍（<a href="#17.2">17.2-17.4</a>）。</p>
<p>接下来的课：</p>
<ul>
<li>在线性代数上，存在一个解法，可以在不需要多步梯度下降的情况下，也能解出代价函数的最小值，这是另一种称为正规方程(<strong>normal equations</strong>)的方法。实际上在数据量较大的情况下，梯度下降法比正规方程要更适用一些。</li>
<li>梯度下降的通用算法</li>
</ul>
<h2 id="第三章-线性代数"><a href="#第三章-线性代数" class="headerlink" title="第三章 线性代数"></a>第三章 线性代数</h2><h3 id="3-1-矩阵和向量"><a href="#3-1-矩阵和向量" class="headerlink" title="3-1 矩阵和向量"></a>3-1 矩阵和向量</h3><p>向量是一个 n × 1 的矩阵。</p>
<p>默认的下标从1开始。</p>
<h3 id="3-2-加法和标量乘法"><a href="#3-2-加法和标量乘法" class="headerlink" title="3-2 加法和标量乘法"></a>3-2 加法和标量乘法</h3><h3 id="3-3-矩阵与向量相乘"><a href="#3-3-矩阵与向量相乘" class="headerlink" title="3-3 矩阵与向量相乘"></a>3-3 矩阵与向量相乘</h3><p>一元线性回归可以转换成矩阵和向量相乘。</p>
<p>下图是矩阵和向量的构造方法，以及代码。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/12.jpg'  width="70%" height="70%"/ loading="lazy">



<h3 id="3-4-矩阵乘法"><a href="#3-4-矩阵乘法" class="headerlink" title="3-4 矩阵乘法"></a>3-4 矩阵乘法</h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/13.jpg' / loading="lazy">



<h3 id="3-5-矩阵乘法的性质"><a href="#3-5-矩阵乘法的性质" class="headerlink" title="3-5 矩阵乘法的性质"></a>3-5 矩阵乘法的性质</h3><p>矩阵乘法是：</p>
<ul>
<li>不可交换的 A × B ≠ B × A </li>
<li>可结合的  (A × B)× C &#x3D; A ×(B× C）</li>
</ul>
<p>单位矩阵 I ：</p>
<ul>
<li>A · I &#x3D; I · A &#x3D; A</li>
</ul>
<h3 id="3-6-逆、转置"><a href="#3-6-逆、转置" class="headerlink" title="3-6 逆、转置"></a>3-6 逆、转置</h3><p>矩阵的逆</p>
<ul>
<li>AA<sup>-1</sup> &#x3D; A<sup>-1</sup>A &#x3D; I ，A是满秩方阵</li>
</ul>
<p>矩阵的转置</p>
<ul>
<li>A<sup>T</sup><sub>ij</sub> &#x3D; A<sub>ji</sub></li>
</ul>
<hr>
<h2 id="第四章-多变量线性回归（Linear-Regression-with-Multiple-Variables）"><a href="#第四章-多变量线性回归（Linear-Regression-with-Multiple-Variables）" class="headerlink" title="第四章 多变量线性回归（Linear Regression with Multiple Variables）"></a>第四章 多变量线性回归（Linear Regression with Multiple Variables）</h2><h3 id="4-1-多维特征"><a href="#4-1-多维特征" class="headerlink" title="4-1 多维特征"></a>4-1 多维特征</h3><p>从只有1个变量的情况，推广到有m组n维特征的情况。</p>
<p>$h_\theta(x) &#x3D; \theta_0 + \theta_1x_1 + \theta_2x_2 + … + \theta_nx_n$</p>
<p>设x<sub>0</sub> &#x3D; 1，则$h_\theta(x) &#x3D; \theta^Tx$（写成向量内积表达式）</p>
<h3 id="4-2-多变量梯度下降"><a href="#4-2-多变量梯度下降" class="headerlink" title="4.2 多变量梯度下降"></a>4.2 多变量梯度下降</h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/14.jpg'  width="70%" height="70%"/ loading="lazy">



<h3 id="4-3-梯度下降技巧1-特征缩放"><a href="#4-3-梯度下降技巧1-特征缩放" class="headerlink" title="4.3 梯度下降技巧1-特征缩放"></a><span id="4.3">4.3 梯度下降技巧1-特征缩放</span></h3><p>当多个特征取值范围相差很大，梯度下降收敛得很慢。</p>
<p>因此，进行<strong>Feature Scaling</strong>，将每个特征都控制在约 -1 ≤ x<sub>i</sub> ≤ 1 的范围内。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/15.jpg'  width="70%" height="70%"/ loading="lazy">

<p> 除了除以最大值，还有一个均值归一化的工作（<strong>mean normalization</strong>），让特征的均值接近0.</p>
<p>具体做法是用 （x<sub>i</sub> - μ<sub>i</sub>）代替 x<sub>i</sub>。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/16.jpg'  width="70%" height="70%"/ loading="lazy">



<h3 id="4-4-梯度下降技巧2-学习率"><a href="#4-4-梯度下降技巧2-学习率" class="headerlink" title="4.4 梯度下降技巧2-学习率"></a><span id="4.4">4.4 梯度下降技巧2-学习率</span></h3><p>绘制随迭代次数增加，代价函数值的变化图象，来确定梯度下降算法在正常运行。</p>
<p>也可以用设置阈值（检测平滑）的方式自动测试，但确定阈值是困难的。看图像在大多数时候更方便直观。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/17.jpg' / loading="lazy">

<p>当代价函数曲线是上升的或不收敛，通常的解决方法是使用更小的 α 值。</p>
<p>α 太小会让收敛变得很慢，多试几次，选一个合适的 α 值。</p>
<h3 id="4-5-选择合适的特征和多项式回归（polynomial-regression）"><a href="#4-5-选择合适的特征和多项式回归（polynomial-regression）" class="headerlink" title="4.5 选择合适的特征和多项式回归（polynomial regression）"></a><span id="4.5">4.5 选择合适的特征和多项式回归（polynomial regression）</span></h3><p>通过对函数图像的了解，和对数据的了解，<strong>选择合适的特征</strong>，来获得更好的模型。</p>
<p>如预测房屋价格，可以选择房屋的size，或者房屋的宽度等特征。</p>
<p>用多项式回归（<strong>polynomial regression</strong>）来理解选择特征：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/18.jpg' / loading="lazy">

<p>​		作简单的处理来拟合多项式模型：让x<sub>i</sub>为size的i次方，或对size开方。</p>
<p>​		在这种指数变换的情况下，做特征scaling是很有必要的。</p>
<p>也有些算法能够观察给出的数据，<strong>自动</strong>选择特征。</p>
<h3 id="4-6-正规方程"><a href="#4-6-正规方程" class="headerlink" title="4.6 正规方程"></a>4.6 正规方程</h3><p>对于某些<strong>线性回归问题</strong>，正规方程可以求解参数 θ 的最优值。</p>
<p><strong>正规方程：</strong></p>
<p>当 θ 是一个实数，让代价函数导数为0，可以解出 θ 的值。（函数求极小值，找导数为 0 的点）</p>
<p>推广到 θ 是向量，通过设置代价函数的偏导数为0，求解 θ 。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/19.jpg'  width="70%" height="70%"/ loading="lazy">

<p>具体做法：构造 m*(n+1) 矩阵 X 和 m 维向量 y ，用最小二乘法计算 θ 。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/20.jpg'  width="70%" height="70%"/ loading="lazy">



<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/21.jpg'  width="60%" height="60%"/ loading="lazy">

<p><strong>使用正规方程法，不需要做特征scaling。</strong></p>
<p>线性回归问题的求解参数 θ：</p>
<ul>
<li><p>梯度下降：在减小代价函数的过程中，<strong>迭代变换  θ</strong> 。</p>
<ul>
<li>需要选择 α 并进行需要多次迭代</li>
</ul>
</li>
<li><p>正规方程：<strong>解析求解，只需一步</strong>。</p>
<ul>
<li>n 很大时，(X<sup>T</sup>X)<sup>-1</sup> 很难算（可以把 n&#x3D;10000 当作进行选择的边缘）</li>
</ul>
</li>
</ul>
<h3 id="4-7-正规方程及不可逆性"><a href="#4-7-正规方程及不可逆性" class="headerlink" title="4.7 *正规方程及不可逆性"></a><span id="4.7">4.7 *正规方程及不可逆性</span></h3><p>使用正规方程求解参数 $\theta &#x3D; (X^TX)^{-1}X^Ty$ 时，如果：</p>
<p><strong>X<sup>T</sup>X不可逆</strong>时（其实发生得很少）</p>
<ul>
<li>咋办？	如在Octave里，有<strong>求伪逆的函数 pinv</strong>，矩阵不可逆时也可以正常求解。 </li>
<li>原因？    矩阵不满秩。<ul>
<li><strong>多个 x 线性相关</strong>。修改冗余的特征</li>
<li><strong>m≤n（特征多，数据少）</strong>。用正则化（<strong>regularization</strong>）解决</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第五章-Octave-Tutorial"><a href="#第五章-Octave-Tutorial" class="headerlink" title="第五章 Octave Tutorial"></a>第五章 Octave Tutorial</h2><p>由于Octave不再具有先进性，我学习了Python3的numpy和pandas库，<a target="_blank" rel="noopener" href="https://github.com/ACBGZM/ml-notes/tree/master/ng-ml2014/code/01-numpyandpandas">笔记见代码和注释</a>。</p>
<p><em><strong>（todo：此处总结成一篇文章后，链接到博客）</strong></em></p>
<h3 id="5-6-向量化"><a href="#5-6-向量化" class="headerlink" title="5.6 向量化"></a>5.6 向量化</h3><p>将一般的运算转化成<strong>使用线性代数库的矩阵、向量运算</strong>。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/22.jpg'  width="70%" height="70%"/ loading="lazy">

<p>在线性回归问题，同步更新θ的问题上，向量运算如下：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/23.jpg' / loading="lazy">

<ul>
<li><strong>θ 是向量，α 是数，δ 是向量</strong>。最终目的是<strong>更新 θ 向量</strong>。</li>
<li>对于 δ ，是由多个数组成的向量。<ul>
<li>δ<sub>k</sub> 由 h-y和x<sub>k</sub><sup>(i)</sup>相乘再相加而来，<strong>h-y是差值是一个数，x<sub>k</sub><sup>(i)</sup>是第i行第k个属性值也是一个数，δ<sub>k</sub> 就是一个数</strong>。</li>
<li><strong>δ 是由数组成的向量</strong>。</li>
<li>整体上，也可以看做图片上 $u &#x3D; 2v + 5w$ 的向量相加形式：先纵向形成向量，<strong>所有的h-y是一样的，也就是是一个倍数，x是第i行数据的一个向量。δ就像u一样，做类似的向量×系数再相加</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第六章-逻辑回归（Logistic-Regression）"><a href="#第六章-逻辑回归（Logistic-Regression）" class="headerlink" title="第六章 逻辑回归（Logistic Regression）"></a>第六章 逻辑回归（Logistic Regression）</h2><p>当要预测的 y 是离散的，就是 Classification 问题。</p>
<p>Logistic Regression 算法就是一个广泛应用的 Classification 算法。</p>
<h3 id="6-1-分类问题（classification）"><a href="#6-1-分类问题（classification）" class="headerlink" title="6.1 分类问题（classification）"></a>6.1 分类问题（classification）</h3><p>Q：为什么线性回归不好用了？</p>
<p>A：线性回归解决这类问题的方法是拟合后设置阈值，再区分成离散值。</p>
<p>​	   如图，当在远处值，拉低了直线的斜率，就会让前面的肿瘤被误判成0.</p>
<p>（别忘了 x<sub>0</sub> 默认为1，以此让 θ<sub>0 </sub>作为偏移量，让直线离开原点）</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/24.jpg'  / loading="lazy">

<p>另外，与linear regression不同，logistic regression算法需要让 $h_\theta(x)$ 的值在 [0, 1]。</p>
<h3 id="6-2-假设表示（hypothesis-representation）"><a href="#6-2-假设表示（hypothesis-representation）" class="headerlink" title="6.2 假设表示（hypothesis representation）"></a>6.2 假设表示（hypothesis representation）</h3><p>当有一个分类问题，我们要用哪个方程，来表示我们的假设？</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/25.jpg'  / loading="lazy">

<p>Sigmoid&#x2F;Logistic 方程如图，我们通过拟合出 θ，让 x 和 h 反应真实情况。</p>
<p>从结果上，我们的结论是 $h_\theta(x)&#x3D;P(y&#x3D;1|x;\theta)$ ，即：x 这个样本，有 h 的概率，是 y&#x3D;1 代表的情况.</p>
<p>（” probability that y &#x3D; 1, given x, parameterized by θ “）</p>
<h3 id="6-3-判定边界（decision-boundary）"><a href="#6-3-判定边界（decision-boundary）" class="headerlink" title="6.3 判定边界（decision boundary）"></a>6.3 判定边界（decision boundary）</h3><p>这个概念让我们理解假设函数 h 是如何做出预测的。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/26.jpg'  width="60%" height="60%"/ loading="lazy">

<ul>
<li><p>当 $\theta^Tx ≥ 0$ 时，有  $h_\theta(x) &#x3D; g(\theta^Tx) ≥ 0.5$ ，取离散值 y &#x3D; 1；</p>
</li>
<li><p>当 $\theta^Tx ≤ 0$ 时，有  $h_\theta(x) &#x3D; g(\theta^Tx) ≤ 0.5$ ，取离散值 y &#x3D; 0。</p>
</li>
</ul>
<p>一个例子：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/27.jpg'  width="60%" height="60%"/ loading="lazy">

<p>以上图两个x的情况为例，$\theta$ 可以确定一条直线，把 y &#x3D; 1 和 y &#x3D; 0 的情况分隔开，这条直线就叫判定边界。</p>
<p>在 <a href="#4.5">4.5 节</a>中介绍了多项式回归，在特征 x 中，添加额外的高阶多项式项。在逻辑回归中也适用：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/28.jpg'  width="60%" height="60%"/ loading="lazy">

<p>区别是线性回归改的是 $h_\theta(x) &#x3D; \theta^Tx$，而逻辑回归问题改的是 $\theta^Tx$ ， $h_\theta(x) &#x3D; g(\theta^Tx)$。</p>
<p>需要注意的是：判定边界是由 θ 确定的，不是由训练集定义的。训练集的 x 所做的只是拟合出合适的 θ。</p>
<p>问题来了：如何根据数据，自动拟合出参数 θ ？（有些包的函数可以，如scipy）</p>
<h3 id="6-4-代价函数（cost-function）"><a href="#6-4-代价函数（cost-function）" class="headerlink" title="6.4 代价函数（cost function）"></a>6.4 代价函数（cost function）</h3><p>问题如下：如何选择 θ ？该定义怎样的代价函数来迭代 θ ？</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/29.jpg'  width="50%" height="50%"/ loading="lazy">

<p>在线性回归问题中，$h_\theta(x)&#x3D;\theta^Tx$ 是线性函数，定义 $Cost(h_\theta(x), y) &#x3D; \frac{1}{2}(h_\theta(x)-y)^2$ ，进而定义代价函数 $J(\theta) &#x3D; \frac{1}{m} \Sigma Cost$。$J(\theta)$是 convex 函数，梯度下降可以应用。</p>
<p>而在逻辑回归问题中， $h_\theta(x) &#x3D; \frac{1}{1+e^{-\theta^Tx}}$ <strong>不是线性</strong>的，如果还是像线性回归那样计算 $J(\theta)$ ，会发现 $J(\theta)$ 是一个 <strong>non-convex 函数，使梯度下降无法应用</strong>。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/30.jpg'  width="60%" height="60%"/ loading="lazy">

<p>需要另外找一个是凸函数的Cost函数：</p>
<div>
$$
Cost(h_\theta(x), y)=
\begin{cases} 
-log(h_\theta(x)),&\text{if }  \quad y=1 \\
-log(1-h_\theta(x)),&\text{if }  \quad y=0
\end{cases}
$$
</div>


<ul>
<li>y &#x3D; 1 时，预测出的 h 越偏离 1，Cost 越大；</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/31.jpg'  width="60%" height="60%"/ loading="lazy">

<ul>
<li>y &#x3D; 0 时，预测出的 h 越偏离 0，Cost 越大。</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/32.jpg'  width="60%" height="60%"/ loading="lazy">

<p>本节定义了单训练样本的代价函数，虽然没有进行详细的凸性分析，但代价函数此时是凸函数。接下来将扩展此结论，给出整个训练集的代价函数的定义。并给出更简单的写法。</p>
<h3 id="6-5-简化代价函数和应用梯度下降"><a href="#6-5-简化代价函数和应用梯度下降" class="headerlink" title="6.5 简化代价函数和应用梯度下降"></a>6.5 简化代价函数和应用梯度下降</h3><p><strong>简化代价函数：</strong></p>
<ul>
<li>逻辑回归的代价函数：</li>
</ul>
<p>$$J(\theta) &#x3D; \frac{1}{m}\sum_{i&#x3D;1}^{m}Cost({h_\theta(x^{(i)}), y^{(i)}})$$</p>
<div>
$$\begin{equation}
Cost(h_\theta(x), y)=\left\{
\begin{array}{rcl}
-log(h_\theta(x)) & \text{if} \quad y=1\\
-log(1-h_\theta(x)) & \text{if} \quad y=0\\
\end{array} \right.
\end{equation}$$
</div>

<p>$$Note:y总是取0或1$$</p>
<ul>
<li>Cost函数简写为：</li>
</ul>
<p>$$Cost(h_\theta(x), y)&#x3D; -y \log h_\theta(x)-(1-y) \log(1-h_\theta(x))$$</p>
<ul>
<li>代价函数简写为：</li>
</ul>
<p>$$J(\theta) &#x3D; -\frac{1}{m}[\sum_{i&#x3D;1}^{m}y^{(i)} \log h_\theta(x^{(i)})+(1-y^{(i)}) \log(1-h_\theta(x^{(i)}))]$$</p>
<p>Q：为什么选择这样形式的代价函数？</p>
<p>A：虽然没有详细解释，但这个式子是通过极大似然法得来的，是统计学中，为不同的模型快速寻找参数的方法。并且这是一个convex函数。</p>
<p><strong>应用梯度下降：</strong></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/33.jpg' / loading="lazy">

<p>（todo：↑ 上式少写了一个 $\frac{1}{m}$？）</p>
<p>从形式上，逻辑回归和线性回归的梯度下降表达式一样。但两者的 $h_\theta(x)$ 定义不同，实际上是完全不同的东西。</p>
<p>在线性回归介绍的方法，像 <a href="#4.4">如何监控梯度下降正常运行</a>、<a href="#4.3">feature scaling</a> 在逻辑回归也适用。</p>
<h3 id="6-6-高级优化"><a href="#6-6-高级优化" class="headerlink" title="6.6 高级优化"></a>6.6 高级优化</h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/34.jpg' / loading="lazy">

<p>除了梯度下降，还有其他的高级算法能让 $J(\theta)$ 收敛。如共轭梯度、BFGS、L-BFGS。</p>
<p>只需知道用法即可，不一定要弄清所有的实现细节，也不要自己去实现这些算法。</p>
<pre class="language-matlab" data-language="matlab"><code class="language-matlab"><span class="token keyword">function</span> <span class="token punctuation">[</span>jVal<span class="token punctuation">,</span> gradient<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">costFunction</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span>
	jVal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">theta</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">theta</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">;</span>
	gradient <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">gradient</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">theta</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">gradient</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">theta</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

options <span class="token operator">=</span> <span class="token function">optimset</span><span class="token punctuation">(</span><span class="token string">'GradObj'</span><span class="token punctuation">,</span> <span class="token string">'on'</span><span class="token punctuation">,</span> <span class="token string">'MaxIter'</span><span class="token punctuation">,</span> <span class="token string">'100'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
initialTheta <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>optTheta<span class="token punctuation">,</span> functionVal<span class="token punctuation">,</span> exitFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fminunc</span><span class="token punctuation">(</span><span class="token operator">@</span>costFunction<span class="token punctuation">,</span> initialTheta<span class="token punctuation">,</span> options<span class="token punctuation">)</span></code></pre>

<p>以上代码调用 fminunc 来进行函数的收敛和 optTheta 的迭代。</p>
<p>对于一般场景的逻辑回归，多个theta的处理方式如下：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/35.jpg'  width="60%" height="60%"/ loading="lazy">



<h3 id="6-7-多分类问题：一对多（multi-class-classification）"><a href="#6-7-多分类问题：一对多（multi-class-classification）" class="headerlink" title="6.7 多分类问题：一对多（multi-class classification）"></a><span id='6.7'>6.7 多分类问题：一对多（multi-class classification）</span></h3><p>训练集的数据有多个分类，如何拟合分类器？</p>
<p>one-vs-all 方法：把训练集的每个类别分别单独拟合一个分类器。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/36.jpg'  width="70%" height="70%"/ loading="lazy">

<p>训练一个逻辑回归分类器 $h_\theta^{(i)}(x)$ ，对于每个类别 $i$ ，分类器预测 $y &#x3D; i$ 的概率。</p>
<p>为了预测任意一个输入 $x$ 的分类，取 $\max i: h_\theta^{(i)}(x)$ ，即让分类器取最大概率值的 $i$ 类别。</p>
<hr>
<h2 id="第七章-正则化（Regularization）"><a href="#第七章-正则化（Regularization）" class="headerlink" title="第七章 正则化（Regularization）"></a>第七章 正则化（Regularization）</h2><h3 id="7-1-过拟合问题（overfitting）"><a href="#7-1-过拟合问题（overfitting）" class="headerlink" title="7.1 过拟合问题（overfitting）"></a><span id="7.1">7.1 过拟合问题（overfitting）</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/37.jpg'  width="70%" height="70%"/ loading="lazy">

<ul>
<li><p><strong>过拟合（overfit）</strong>：过于贴近训练数据的特征了，在训练集上近乎完美的预测&#x2F;区分了所有的数据，但是<strong>缺乏泛化能力</strong>，在新的测试集上表现不佳。</p>
</li>
<li><p><strong>欠拟合（underfit）</strong>：测试样本的特性没有学习到，或模型过于简单无法拟合或区分样本。</p>
</li>
</ul>
<p>(<strong>识别过拟合、欠拟合的情况。</strong>)</p>
<p>当 <strong>features 的数量太多</strong>，甚至比 training data 的数量都多，就很有可能出现过拟合。比如像窗户的数量、门的数量等特征，看上去都与房屋的价格有关。</p>
<p><strong>解决过拟合问题的方法</strong>：</p>
<ul>
<li><strong>减少特征的数量</strong><ul>
<li>人工选择特征，进行取舍。舍弃特征的同时也会舍弃信息。</li>
<li>使用模型选择算法，自动选择保留的特征。（在之后介绍）</li>
</ul>
</li>
<li><strong>正则化（regularization）</strong><ul>
<li>保留所有特征，但减少参数 $\theta_j$ 的量级&#x2F;大小。</li>
<li>情况：有多个特征、并且每个特征都是或多或少有用的，我们不希望把他们舍弃掉。</li>
</ul>
</li>
</ul>
<h3 id="7-2-正则化的直观理解、代价函数（cost-function）"><a href="#7-2-正则化的直观理解、代价函数（cost-function）" class="headerlink" title="7.2 正则化的直观理解、代价函数（cost function）"></a><span id="7.2">7.2 正则化的直观理解、代价函数（cost function）</span></h3><h4 id="正则化的直观理解："><a href="#正则化的直观理解：" class="headerlink" title="正则化的直观理解："></a>正则化的直观理解：</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/38.jpg'  width="60%" height="60%"/ loading="lazy">

<p>通过减小参数 θ<sub>3</sub>、θ<sub>4</sub> 的值，给 x<sub>3</sub>、x<sub>4</sub> 两个特征加入惩罚，曲线就跟二次函数没什么区别了。</p>
<p>这就是正则化背后思想：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/39.jpg'  width="60%" height="60%"/ loading="lazy">

<p>不知道具体哪些特征 x 该舍弃掉，就<strong>减小所有参数 θ</strong> 。</p>
<h4 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h4><p>在 $J(\theta)$ 后面加上一项 $\lambda\sum^{n}_{i&#x3D;1}\theta_j^2$ ，在收敛 $J(\theta)$ 的同时让所有 $\theta$ 变小。</p>
<p>tips：</p>
<ul>
<li>通常不含常数项 $\theta_0$ ，但影响不大。</li>
<li>要<strong>选择合适的正则化参数 $\lambda$<strong>。$\lambda$ 的作用是在两个目标中平衡：表达式前面的项代表</strong>对数据更好的拟合</strong>，后面的项代表<strong>让参数尽量小来避免过拟合</strong>。<ul>
<li>$\lambda$ 越大，$\theta$ 的惩罚越大。如果 $\lambda$ 太大，$\theta$ 都接近0，就相当于把假设函数的项都忽略掉了，最后只剩一个常数项 $\theta _0$，造成欠拟合。</li>
</ul>
</li>
</ul>
<p>(问题：<strong>如何自动选择 $\lambda$</strong> ？)</p>
<h3 id="7-3-线性回归的正则化（regularized-linear-regression）"><a href="#7-3-线性回归的正则化（regularized-linear-regression）" class="headerlink" title="7.3 线性回归的正则化（regularized linear regression）"></a><span id="7.3">7.3 线性回归的正则化（regularized linear regression）</span></h3><p>拟合线性回归模型的两种算法：<strong>基于梯度下降、基于正规方程</strong>。</p>
<h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>在 $J(\theta)$ 的最后加一项 $\frac{\lambda}{2m}\sum^n_{j&#x3D;1}\theta^2_j$ 。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/40.jpg'  width="60%" height="60%"/ loading="lazy">

<p>梯度下降，求偏导 $\frac{\lambda}{m}\theta_j$ ：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/41.jpg'  width="60%" height="60%"/ loading="lazy">

<p>直观的理解，正则化的梯度下降是让 $\theta_j$ <strong>每次额外乘以一个比1略小的数</strong> $(1-\alpha\frac{\lambda}{m})$ ，每次都把参数改小一点。</p>
<p>将 θ<sub>0</sub> 和其余 θ 区别开。（$(1-\alpha\frac{\lambda}{m})$ 跟1差不多大，所以区分开的影响不大。可以对比两个式子看正则化给梯度下降带来的变化。）</p>
<h4 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h4><p>回忆一下正规方程：构造 m*(n+1) 矩阵 X 和 m 维向量 y ，设定代价函数的导数为 0，用最小二乘法计算 θ。</p>
<p>正规方程正则化的方式是加一个 (n+1)*(n+1) 的方阵，这个方阵的构造如下图所示。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/42.jpg'  width="60%" height="60%"/ loading="lazy">

<p>*<strong>正则化中的 $X^TX$不可逆问题（见<a href="#4.7">4.7</a>）</strong>：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/43.jpg'  width="60%" height="60%"/ loading="lazy">

<p>在不进行正则化时，一些语言的库函数也可以<strong>计算不可逆的矩阵</strong>。</p>
<p>进行正则化后，如果 $\lambda&gt;0$ ，可证得 $(X^TX+\lambda R)$ <strong>一定是可逆的</strong>。</p>
<h3 id="7-4-逻辑回归的正则化（regularized-logistic-regression）"><a href="#7-4-逻辑回归的正则化（regularized-logistic-regression）" class="headerlink" title="7.4 逻辑回归的正则化（regularized logistic regression）"></a><span id="7.4">7.4 逻辑回归的正则化（regularized logistic regression）</span></h3><p>跟线性回归的梯度下降差不多。</p>
<p>在 $J(\theta)$ 的最后加一项 $\frac{\lambda}{2m}\sum^n_{j&#x3D;1}\theta^2_j$ 。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/44.jpg'  width="60%" height="60%"/ loading="lazy">

<p>梯度下降求偏导 $\frac{\lambda}{m}\theta_j$ ：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/45.jpg'  width="60%" height="60%"/ loading="lazy">

<p>实现方法：先定义代价函数：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/46.jpg'  width="60%" height="60%"/ loading="lazy">

<p>再把代价函数用到fminunc：<code>fminunc(@costFunction);</code> 。</p>
<hr>
<h2 id="第八章-神经网络：表述（Neural-Networks-Representation）"><a href="#第八章-神经网络：表述（Neural-Networks-Representation）" class="headerlink" title="第八章 神经网络：表述（Neural Networks: Representation）"></a>第八章 神经网络：表述（Neural Networks: Representation）</h2><h3 id="8-1-非线性假设"><a href="#8-1-非线性假设" class="headerlink" title="8.1 非线性假设"></a><span id="8.1">8.1 非线性假设</span></h3><p>Q：为什么要学习神经网络算法？（跟线性回归、逻辑回归相比有什么先进性）</p>
<p>A：如果<strong>n太大，feature太多</strong>，之前介绍的算法就不理想了。 对于许多实际的机器学习问题，n一般是很大的。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/47.jpg'  width="60%" height="60%"/ loading="lazy">

<p>如图，100个n会产生约5000个二次项，对应同样多的参数。如果包含所有的二次项，运算量会很大，并且很可能会出现过拟合的现象。如果再包含三次项，……。当<strong>n很大</strong>，通过增加feature来建立非线性分类器不是一个好办法。</p>
<p>而现实中的问题往往有很大的n。如50*50分辨率的灰度图像，要存储每个像素的值，n&#x3D;50*50&#x3D;2500；进行特征映射，n&#x3D;2500*2500&#x2F;2≈3,000,000。</p>
<h3 id="8-2-神经元和大脑"><a href="#8-2-神经元和大脑" class="headerlink" title="8.2 神经元和大脑"></a><span id="8.2">8.2 神经元和大脑</span></h3><p>可以用单个算法来模拟大脑的学习算法吗？</p>
<p>本节课举例论证了：人的一些感官是相通的——可以把任何sensor接入大脑，然后大脑的学习算法就能找出学习数据的方法，并处理这些数据。</p>
<p>现在的问题：如何找出大脑的学习算法？</p>
<h3 id="8-3-模型表示Ⅰ"><a href="#8-3-模型表示Ⅰ" class="headerlink" title="8.3 模型表示Ⅰ"></a><span id="8.3">8.3 模型表示Ⅰ</span></h3><p>当使用神经网络时，如何表示我们的假设或模型？大脑里的神经元是相互连接的，通过接收、处理、传递电信号的方式工作 。</p>
<p>通过以下方式表示单个的人工神经元：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/48.jpg'  width="80%" height="80%"/ loading="lazy">

<p>模型的表示：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/49.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li><p>用 $a_i^{(j)}$ 表示第 $j$ 层的第 $i$ 个神经元。</p>
</li>
<li><p>用 $\Theta^{(j)}$ 表示从第 $j$ 层到 $j+1$  层的权重矩阵。</p>
</li>
<li><p>如果一个网络，在第 $j$ 层有 $s_j$ 个单元，在第 $j+1$ 层有 $s_{j+1}$ 个单元，那么 $\Theta^{(j)}$ 的维度是 $s_{j+1}×(s_j+1)$。是<strong>从后往前</strong>的形式。</p>
<ul>
<li>我的理解：矩阵的行是下一层的每个神经元的权重列表，列对应上一层的神经元。列要加一是<strong>加上上一层的偏置</strong>，也就是$x_0$。</li>
</ul>
</li>
</ul>
<h3 id="8-4-模型表示Ⅱ：向量化和前向传播"><a href="#8-4-模型表示Ⅱ：向量化和前向传播" class="headerlink" title="8.4 模型表示Ⅱ：向量化和前向传播"></a><span id="8.4">8.4 模型表示Ⅱ：向量化和前向传播</span></h3><p><em>本章直观地理解向量化的方法，并明白为什么这是学习复杂的非线性假设函数的好方法。</em></p>
<p>向前传播的向量化：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/50.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li><p>$z^{(j+1)} &#x3D; \Theta^{(j)}a^{(j)}$，每层的 $z:(s_{j+1}×1)$ 是偏置矩阵 $\Theta:(s_{j+1}×(s_j+1))$ 和上层的输出 $a:((s_j+1)×1)$ 做矩阵运算得出的。</p>
</li>
<li><p>$a^{(j)} &#x3D; g(z^{(j)})$，每行的输出 $a$ 是对 $z$ 做 sigmoid 运算。</p>
</li>
<li><p>每一层都添加偏置  $a_0^{(j)}&#x3D;1$</p>
</li>
</ul>
<p>这种前向传播的方法也可以帮助我们了解神经网络的作用，和神经网络算法为什么能在学习非线性假设函数时有好的表现。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/51.jpg'  width="80%" height="80%"/ loading="lazy">

<p>神经网络在每一层都像是做一个逻辑回归，根据输入拟合一些权值；而且每层的输入都是前层根据自动拟合的权值，计算得到的输出，因此可以包含一些很复杂的特征。神经网络可以利用隐藏层计算更复杂的特征，并最终输出到输出层。</p>
<p><em>在接下来的两章，讨论具体的例子，描述如何利用神经网络来计算输入的非线性假设函数。</em></p>
<h3 id="8-5-举例直观理解Ⅰ"><a href="#8-5-举例直观理解Ⅰ" class="headerlink" title="8.5 举例直观理解Ⅰ"></a><span id="8.5">8.5 举例直观理解Ⅰ</span></h3><p>使用神经网络计算 AND 门：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/52.jpg'  width="80%" height="80%"/ loading="lazy">

<p>计算 OR 门：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/53.jpg'  width="80%" height="80%"/ loading="lazy">

<p>只要设置恰当的权值，神经网络就能起到相应的作用。</p>
<h3 id="8-6-举例直观理解Ⅱ"><a href="#8-6-举例直观理解Ⅱ" class="headerlink" title="8.6 举例直观理解Ⅱ"></a><span id="8.6">8.6 举例直观理解Ⅱ</span></h3><p>使用感知机来解决非线性问题：亦或。</p>
<p>使用有一层隐藏层的神经网络计算 NOR 函数：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/54.jpg'  width="80%" height="80%"/ loading="lazy">

<p>x<sub>1</sub> NOR x<sub>2</sub> &#x3D; (x<sub>1</sub> AND x<sub>2</sub>)    OR    ( (NOT x<sub>1</sub>) AND (NOT x<sub>2</sub>) )</p>
<p>通过识别手写数字的视频展示了，神经网络可以学习相当复杂的函数，并且有一定的抗干扰能力：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/55.jpg'  width="60%" height="60%"/ loading="lazy">



<h3 id="8-7-神经网络的多元分类问题（multi-class-clasification）"><a href="#8-7-神经网络的多元分类问题（multi-class-clasification）" class="headerlink" title="8.7 神经网络的多元分类问题（multi-class clasification）"></a><span id="8.7">8.7 神经网络的多元分类问题（multi-class clasification）</span></h3><p>上节的手写数字识别问题就是多分类问题，需要识别10种类型的数字。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/56.jpg'  width="80%" height="80%"/ loading="lazy">

<p>方法是设置多个输出层神经元，再把训练集 $(x^{(i)},y^{(i)})$ 、输出 $h_\Theta(x^{(i)})&#x3D;y^{(i)}$ 的 $y$ 都变成向量的形式。途中输出分成四类，则 $y$ 是四维向量。</p>
<p><em>本章讲述了如何构建模型来表示神经网络算法。在下一章，将学习如何构建训练集，如何让神经网络自动学习参数。</em></p>
<h2 id="第九章-神经网络的学习（Neural-Networks-Learning）"><a href="#第九章-神经网络的学习（Neural-Networks-Learning）" class="headerlink" title="第九章 神经网络的学习（Neural Networks: Learning）"></a>第九章 神经网络的学习（Neural Networks: Learning）</h2><p>讲一个学习算法，可以在给定数据集上，为神经网络拟合参数。</p>
<h3 id="9-1-代价函数（cost-function）"><a href="#9-1-代价函数（cost-function）" class="headerlink" title="9.1 代价函数（cost function）"></a><span id="9.1">9.1 代价函数（cost function）</span></h3><h4 id="神经网络的符号表示："><a href="#神经网络的符号表示：" class="headerlink" title="神经网络的符号表示："></a>神经网络的符号表示：</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/57.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li><p>$L$：层数</p>
</li>
<li><p>$s_l$：第 $l$ 层的神经元数（不含偏置神经元）</p>
</li>
<li><p>$K$：输出神经元的个数。</p>
<ul>
<li>二元神经网络的 $s_l&#x3D;K&#x3D;1$，多元神经网络的 $s_l&#x3D;K$。</li>
<li>$h_\Theta(x) ∈ \R^K$</li>
</ul>
</li>
</ul>
<h4 id="神经网络的代价函数："><a href="#神经网络的代价函数：" class="headerlink" title="神经网络的代价函数："></a>神经网络的代价函数：</h4><p>逻辑回归的代价函数一般表达式如下：</p>
<p>$$J(\theta) &#x3D; -\frac{1}{m}\bigg[\sum_{i&#x3D;1}^{m}y^{(i)} \log h_\theta(x^{(i)})+(1-y^{(i)}) \log(1-h_\theta(x^{(i)}))\bigg]+\frac{\lambda}{2m}\sum_{j&#x3D;1}^n\theta^2_j$$<br>对于神经网络，有</p>
<p>$$h_\Theta(x)∈\R^K,(h_\Theta(x))_i&#x3D;i^{th} output$$</p>
<div>
$$
J(\Theta) = -\frac{1}{m}\bigg[\sum_{i=1}^{m}\sum_{k=1}^{K}y^{(i)}_k \log (h_\Theta(x^{(i)}))_k+(1-y^{(i)}_k) \log(1-h_\Theta(x^{(i)}))_k\bigg] \\
+\frac{\lambda}{2m}\sum_{l=1}^{L-1}\sum_{i=1}^{s_l}\sum_{j=1}^{s_{l+1}}(\Theta^{(l)}_{ji})^2
$$
</div>

<p>与逻辑回归的代价函数不同点在于：</p>
<ul>
<li><p>把 K 个输出神经元的损失加起来，再求 m 个数据上的平均</p>
</li>
<li><p>正则化项，取所有边权重的平方和。i 从1开始，不含偏移神经元的权重。</p>
</li>
</ul>
<h3 id="9-2-反向传播算法（backpropagation-algorithm）"><a href="#9-2-反向传播算法（backpropagation-algorithm）" class="headerlink" title="9.2 反向传播算法（backpropagation algorithm）"></a><span id="9.2">9.2 反向传播算法（backpropagation algorithm）</span></h3><p><em>一个让上节的损失函数取到最小值的算法</em></p>
<p>上节定义了 $J(\Theta)$，如果想让 $J(\Theta)$ 取到最小值，就需要计算 $\frac{\partial}{\partial\Theta^{(l)}_{ij}}J(\Theta)$</p>
<p>首先来看<strong>前向传播的向量化</strong>：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/58.jpg'  width="80%" height="80%"/ loading="lazy">

<p>此处可以仔细理解一下<strong>前向传播的计算过程</strong>。</p>
<ul>
<li>以上图为例，如果只有一组数据集 $(x, y)$，</li>
<li>$a^{(1)}$的规格是 3×1，$\Theta^{(1)}$的规格是 5×3，</li>
<li>向量化后相乘，得到 $z^{(2)}$的规格是 5×1，求sigmoid后加一个偏移项则 $a^{(2)}$的规格是 6×1，</li>
<li>$\Theta^{(2)}$的规格是 5×6，相乘得到 $z^{(2)}$的规格是 5×1，</li>
<li>以此类推。使用前向传播，可以从输入，通过神经网络，得到输出。</li>
</ul>
<p>回到主题，为了计算导数项 $\frac{\partial}{\partial\Theta^{(l)}_{ij}}J(\Theta)$，需要使用<strong>反向传播算法</strong>：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/59.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li><p>对于每一个节点，我们计算这样一项 $\delta^{(l)}_j$，<strong>代表了第 $l$ 层第 $j$ 个节点的“误差”</strong></p>
</li>
<li><p><strong>从输出层，反向计算每层的误差</strong>。</p>
</li>
<li><p>然后，根据 $\frac{\partial}{\partial\Theta^{(l)}_{ij}}J(\Theta) &#x3D; a^{(l)}_j\delta^{(l+1)}_i$（此式省略了 $\lambda$ 等参数），可以<strong>求得想要的偏导数</strong>。</p>
</li>
</ul>
<h4 id="反向传播算法的整体过程"><a href="#反向传播算法的整体过程" class="headerlink" title="反向传播算法的整体过程"></a>反向传播算法的整体过程</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/60.jpg'  width="80%" height="80%"/ loading="lazy">


<ul>
<li><p>有训练集 ${( x^{(1)},y^{(1)} ),…,(x^{(m)},y^{(m)})   }$</p>
</li>
<li><p><strong>设置初始误差矩阵</strong> $\Delta^{(l)}_{ij}&#x3D;0$，保存整个神经网络的误差</p>
</li>
<li><p>For $i&#x3D;1$ to $m$ ：</p>
<ul>
<li><strong>设置输入层</strong> $a^{(1)}&#x3D;x^{(1)}$</li>
<li>进行<strong>前向传播</strong>，求<strong>每层输出</strong> $a^{(l)}$</li>
<li>使用 $y^{(i)}$ ，计算<strong>输出层的误差</strong>  $\delta^{(L)} &#x3D;a^{(L)}-y^{(i)}$</li>
<li>进行<strong>反向传播</strong>，计算<strong>每层误差</strong> $\delta^{(L-1)},\delta^{(L-2)},…,\delta^{(2)}$</li>
<li><strong>累加误差矩阵</strong> $\Delta^{(l)}_{ij}:&#x3D;\Delta^{(l)}_{ij}+ a^{(l)}_j\delta^{(l+1)}_i$</li>
</ul>
</li>
<li><p>计算 $D$</p>
<ul>
<li>$D^{(l)}_{ij}:&#x3D;\frac{1}{m}\Delta^{(l)}_{ij}+\lambda\Theta^{(l)}_{ij}$，if $j ≠0$</li>
<li>$D^{(l)}_{ij}:&#x3D;\frac{1}{m}\Delta^{(l)}_{ij}$               ，if $j &#x3D;0$</li>
</ul>
</li>
<li><p>$\frac{\partial}{\partial\Theta^{(l)}_{ij}}J(\Theta) &#x3D; D^{(l)}_{ij}$ ，求得偏导</p>
</li>
<li><p>使用偏导进行梯度下降，或其他高级优化算法</p>
</li>
</ul>
<p>补充：</p>
<ul>
<li><p>反向传播不用计算 $\delta^{(1)}$ ，因为不需要对输入层考虑误差项。</p>
</li>
<li><p>累加误差矩阵写成向量相乘形式： $\Delta^{(l)}_{ij}:&#x3D;\Delta^{(l)}_{ij}+ \delta^{(l+1)}_i(a^{(l)}_j)^T$</p>
</li>
</ul>
<h3 id="9-3-反向传播算法的直观理解"><a href="#9-3-反向传播算法的直观理解" class="headerlink" title="9.3 反向传播算法的直观理解"></a><span id="9.3">9.3 反向传播算法的直观理解</span></h3><p>前向传播的直观理解：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/61.jpg'  width="80%" height="80%"/ loading="lazy">

<p>反向传播的直观理解：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/62.jpg'  width="80%" height="80%"/ loading="lazy">

<p>可以把神经网络的代价函数中的主要部分，类比为线性回归的代价函数的方差计算。只需明确：本质上做的是“求与真实值y的偏离程度”这件事。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/63.jpg'  width="90%" height="90%"/ loading="lazy">

<p>而反向传播过程中，计算的 $\delta_j^{(l)}$ 就是 <strong>cost 关于 z 的偏导数</strong>。具体来说，cost 是一个关于真实值 y 和神经网络的输出值 h(x) 的函数。 $\delta_j^{(l)}$实际上是 cost 关于这些计算出的中间项的偏导数。$\delta_j^{(l)}$衡量的是，为了影响这些<strong>中间值 z <strong>（进而影响</strong>整个神经网络的输出 h</strong>），我们想要改变的神经网络的<strong>权重</strong>的程度。</p>
<h3 id="9-4-使用注意：展开参数"><a href="#9-4-使用注意：展开参数" class="headerlink" title="9.4 使用注意：展开参数"></a><span id="9.4">9.4 使用注意：展开参数</span></h3><p><em>怎样将参数从矩阵展开成向量，以满足高级最优化步骤中的使用需要</em></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/64.jpg'  width="70%" height="70%"/ loading="lazy">

<p>如上图，定义一个代价函数 costFunction，输入参数是 theta，函数返回代价值 jVal 以及导数值（梯度） gradient。</p>
<p>然后将这个函数传递给高级最优化算法 fminunc，这些库函数都假定 theta、initialTheta 是参数向量，同时假定代价函数的第二个返回值，也就是梯度值 gradient 也是一个向量。</p>
<p>这部分在我们使用逻辑回归的时候没有问题，但在神经网络中，参数矩阵 $\Theta$ 和梯度矩阵$D$ 都是矩阵而非向量，因此需要将这些矩阵展开成向量，从而作为参数输入到函数中。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/65.jpg'  width="70%" height="70%"/ loading="lazy">

<p>以上图 Octave 语言为例：</p>
<ul>
<li>首先有初始参数值矩阵 $\Theta$ ，<strong>将他们展开成向量 initialTheta</strong>，传递到高级优化函数 fminunc 中。</li>
<li>使用 fminunc 函数需要事先定义 costFunction 函数，它的参数是 thetaVec，所有的参数展开成一个向量的形式。因此需要做的第一件事就是用 reshape 功能<strong>将 thetaVec 转换成参数值矩阵</strong> $\Theta$，然后才能进行前向、反向传播，来计算导数 $D$ 和计算代价函数 $J(\Theta)$。最终，<strong>将 $D$ 展开成向量</strong>，得到需要返回的梯度向量 gradientVec。</li>
</ul>
<p>一般是用 reshape() 函数来进行矩阵、向量形式的转换。</p>
<ul>
<li>用矩阵存储的好处：更方便进行正向、反向传播。</li>
<li>用向量存储的好处：一些高级优化算法要求参数要展开成一个长向量的格式。</li>
</ul>
<h3 id="9-5-梯度检验（gradient-checking）"><a href="#9-5-梯度检验（gradient-checking）" class="headerlink" title="9.5 梯度检验（gradient checking）"></a><span id="9.5">9.5 梯度检验（gradient checking）</span></h3><p><em>前面几节讲了怎样在神经网络中进行前向、反向传播，来计算导数。但反向传播算法很难实现，并且在执行上可能出现一些bug，比如 $J(\Theta)$ 减小但最终得到的神经网络误差很大。</em></p>
<p><em>梯度检验思想能解决几乎所有这种问题，能完全保证前向、反向传播算法是百分百正确的。在使用反向传播的场合中，最好做一下梯度检验。</em></p>
<h4 id="第一步：估算导数"><a href="#第一步：估算导数" class="headerlink" title="第一步：估算导数"></a>第一步：估算导数</h4><p><strong>当 $\Theta$ 是实数：</strong></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/66.jpg'  width="70%" height="70%"/ loading="lazy">

<p>在数值上去拟合 $J(\Theta)$ 的导数：</p>
<div>
$$
\frac{d}{d\Theta}≈\frac{J(\Theta+\epsilon)-J(\Theta-\epsilon)}{2\epsilon}
$$
</div>

<p><strong>当 $\Theta$ 是向量：</strong>（比如是从矩阵展开而来的）</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/67.jpg'  width="70%" height="70%"/ loading="lazy">

<p>在Octave的实现：</p>
<pre class="language-octave" data-language="octave"><code class="language-octave">for i &#x3D; 1:n,
	thetaPlus &#x3D; theta;
	thetaPlus(i) &#x3D; thetaPlus(i) + EPSILON;
	thetaMinus &#x3D; theta;
	thetaMinus(i) &#x3D; thetaMinus(i) - EPSILON;
	gradApprox(i) &#x3D; (J(thetaPlus) - J(thetaMinus)) &#x2F; (2 * EPSILON);
end;</code></pre>

<p>用 <code>gradApprox</code> 来近似计算 $\frac{\partial}{\partial\Theta_i}J(\Theta)$</p>
<h4 id="第二步：对比估算值和反向传播的结果"><a href="#第二步：对比估算值和反向传播的结果" class="headerlink" title="第二步：对比估算值和反向传播的结果"></a>第二步：对比估算值和反向传播的结果</h4><p>检查 <code>gradApprox ≈ Dvec</code></p>
<p><code>DVec</code> 是反向传播得出的导数矩阵。检查估算的 <code>gradApprox</code> 是否在数值上跟反向传播算法计算出的导数接近。</p>
<h4 id="总体实现过程："><a href="#总体实现过程：" class="headerlink" title="总体实现过程："></a>总体实现过程：</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/68.jpg'  width="70%" height="70%"/ loading="lazy">

<p>在第三步中，如果估计值和反向传播的结果在数值上近似，那么第四步，就<strong>把梯度检验关掉，不要再计算估计值</strong> <code>gradApprox</code> 了，使用反向传播的结果来进行神经网络的学习。</p>
<p>原因是近似求导计算 <code>gradApprox</code> 是计算量非常大、耗时、不稳定的。而计算 <code>DVec</code> 的反向传播算法是高性能的求导方法（仅向量计算）。</p>
<h3 id="9-6-随机初始化（random-initialization）"><a href="#9-6-随机初始化（random-initialization）" class="headerlink" title="9.6 随机初始化（random initialization）"></a><span id="9.6">9.6 随机初始化（random initialization）</span></h3><p><em>如何初始化 $\Theta$ ？</em></p>
<p>在逻辑回归中，可以将初始参数都设置为 0 .但在训练网络时，将 0 作为初始值起不到任何效果：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/69.jpg'  width="70%" height="70%"/ loading="lazy">

<p>由于权重是相同的（都是0），在前向传播中，同层的节点将会得到相同的输出值；而在反向传播中，也会得到相同的导数值。如图，相同颜色的边会得到相同的权值、偏导。这被称为“对称权重问题（symmetric weights）”</p>
<p>为了解决这个问题，使用随机初始化的思想，进行 symmetry breaking。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/70.jpg'  width="70%" height="70%"/ loading="lazy">

<p>rand取 [0,1]，(2*rand - 1)*EPSILON 取 [-EPSILON, EPSILON].</p>
<p>综合前几节，训练神经网络的过程如下：</p>
<ul>
<li>随机初始化权重于 $[-\epsilon,\epsilon]$</li>
<li>进行反向传播</li>
<li>进行梯度检验</li>
<li>使用梯度下降或其他高级优化算法，最小化 $J(\Theta)$</li>
<li>得出 $\Theta$ 的最优值</li>
</ul>
<h3 id="9-7-组合起来"><a href="#9-7-组合起来" class="headerlink" title="9.7 组合起来"></a><span id="9.7">9.7 组合起来</span></h3><h3 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h3><ul>
<li><h4 id="确定一个网络结构"><a href="#确定一个网络结构" class="headerlink" title="确定一个网络结构"></a>确定一个网络结构</h4><ul>
<li><strong>输入层</strong>单元的个数：数据集中 $x^{(i)}$ 特征的维度</li>
<li><strong>输出层</strong>单元的个数：分类的个数<ul>
<li>对于分类问题，要记得<strong>把输出 y 写成向量的形式</strong>，其中有一项 1 表示哪一类，剩下都为0.</li>
</ul>
</li>
<li><strong>隐藏层</strong>如何设计：<ul>
<li>一个合理的默认选项是使用一个隐藏层。</li>
<li>使用多个隐藏层时，每层的隐藏单元数量相同。（通常越多越好，但要注意计算量问题）</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="需要实现的步骤"><a href="#需要实现的步骤" class="headerlink" title="需要实现的步骤"></a>需要实现的步骤</h4><ul>
<li>① 随机初始化权重</li>
<li>② 实现前向传播算法，计算每条数据 $x^{(i)}$ 经过神经网络得到的输出 $h_\Theta(x^{(i)})$</li>
<li>③ 实现损失函数 $J(\Theta)$</li>
<li>④ 实现反向传播算法，计算偏导 $\frac{\partial}{\partial\Theta^{(i)}_{jk}}J(\Theta)$<ul>
<li>使用一个循环 <code>for i = 1:m</code> 来进行前向传播和反向传播，对于数据集中的每条数据 $(x^{(i)},y^{(i)})$ 计算每层的 $a^{(l)}$ 和 $\delta^{(l)}$ ；然后在循环中更新 $\Delta^{(l)}$</li>
</ul>
</li>
<li>⑤ 实现梯度检验，对比反向传播的结果 $\frac{\partial}{\partial\Theta^{(l)}_{jk}}J(\Theta)$ 和数值上的估计值。然后禁用梯度检验的代码。</li>
<li>⑥ 使用梯度下降算法，跟反向传播结合，最小化 $J(\Theta)$，得到最终权重 $\Theta$</li>
</ul>
</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/71.jpg'  width="70%" height="70%"/ loading="lazy">



<ul>
<li><h4 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h4></li>
</ul>
<p>如下图，① 随机选取一个起始点，④ 反向传播算出梯度下降的方向，⑥ 梯度下降就是沿着这个方向一点点下降，知道到达局部最优点。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/72.jpg'  width="70%" height="70%"/ loading="lazy">



<h3 id="9-8-无人驾驶"><a href="#9-8-无人驾驶" class="headerlink" title="9.8 无人驾驶"></a><span id="9.8">9.8 无人驾驶</span></h3><p><em>一个有趣并具有历史意义的神经网络学习的例子：实现自动驾驶</em></p>
<p>左上方第一个白条显示人类驾驶员选择的方向，第二、三个白条显示两个网络的置信度、以及学习算法选择的行驶方向。</p>
<p>刚开始随机初始化后，输出整段模糊的灰色区域，学习后才集中到一块白亮的小区域，选择明确的驾驶方向。</p>
<p>左下方显示前方景象。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/73.jpg'  width="70%" height="70%"/ loading="lazy">

<p>这个任务基于三层的神经网络，使用反向传播算法。数据集是压缩后的前方图片和驾驶员选择的方向。</p>
<p>训练完成后，每秒钟生成12张数字化的图片，传送给神经网络进行计算，使用输出进行自动驾驶。</p>
<p>分为单行道网络、双车道网络，分别计算置信度（confidence），根据不同的路况，置信度高的网络就被选择来控制行驶方向。</p>
<hr>
<h2 id="第十章-应用机器学习的建议-Advice-for-Applying-Machine-Learning"><a href="#第十章-应用机器学习的建议-Advice-for-Applying-Machine-Learning" class="headerlink" title="第十章 应用机器学习的建议(Advice for Applying Machine Learning)"></a>第十章 应用机器学习的建议(Advice for Applying Machine Learning)</h2><p>给出一些建议，当在开发一个机器学习系统时，如何决定该选择哪条道路。</p>
<p>10.2、10.3讲怎样评估机器学习算法的性能，10.4、10.5讲机器学习诊断法。</p>
<h3 id="10-1-决定下一步做什么"><a href="#10-1-决定下一步做什么" class="headerlink" title="10.1 决定下一步做什么"></a><span id="10.1">10.1 决定下一步做什么</span></h3><p><strong>Debugging a learning algorothm：</strong></p>
<p>假设已经实现了正则化的线性回归，得到用来预测房价的模型：</p>
<div>
$$
J(\theta) = \frac{1}{2m}\bigg[\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})^2 + \lambda\sum^m_{j=1}\theta^2_j\bigg]
$$
</div>

<p>然而，当在训练集上测试得到的参数时，我们发现预测的结果有很大的误差。我们应该如何改进？</p>
<ul>
<li>收集更多的训练样本（在有些时候没有效果。在之后的章节会将如何避免把过多时间浪费在收集样本上）</li>
<li>尝试使用更少的特征</li>
<li>尝试获取更多特征，来收集更多的数据</li>
<li>尝试增加多项式特征（$x^2_1,x^2_2,x_1x_2,etc.$）</li>
<li>尝试增加&#x2F;减小 $\lambda$</li>
</ul>
<p>大多数人的方法是，随便从这些方法中选择一种，然后花很长时间检验这种方法是否有效。</p>
<p>有一种简单的方法，可以轻松地排除掉一些选项：机器学习诊断法（machine learning diagnostic）。我们可以使用诊断法，明确在机器学习算法中，什么有效什么无效，并且可以获得如何提升性能的指导。</p>
<h3 id="10-2-评估一个假设"><a href="#10-2-评估一个假设" class="headerlink" title="10.2 评估一个假设"></a><span id="10.2">10.2 评估一个假设</span></h3><p><em>如何评估学习算法得到的假设。基于这一节，在之后会讲如何防止过拟合和欠拟合的问题。</em></p>
<p>我们获得学习算法的方式是让代价函数取最小，但会产生<strong>过拟合假设</strong>的问题。当在特征少的情况下，我们可以通过函数图像发现过拟合现象，但<strong>当特征多时，函数难以可视化，我们需要另一种评价假设函数的方法</strong>。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/74.jpg'  width="70%" height="70%"/ loading="lazy">

<p>把数据集随机分为训练集和测试集。数量上 7:3 是比较常见的分法。</p>
<p>一种典型的训练、测试线性回归的方法：</p>
<ul>
<li>在 70% 占比的训练集上学习 $\theta$（最小化误差函数$J(\theta)$）</li>
<li>计算出测试误差：$J_{test}(\theta) &#x3D;\frac{1}{2m}\sum^{m_{test}}_{i&#x3D;1}(h_\theta(x^{(i)}_{test})-y^{(i)}_{test})^2$</li>
</ul>
<p>训练、测试逻辑回归：</p>
<ul>
<li>在训练集上学习 $\theta$</li>
<li>在测试集上计算测试误差，有两种定义方法：<ul>
<li>计算逻辑回顾误差：$J_{test}(\theta) &#x3D; -\frac{1}{m_{test}}\sum^{m_{test}}_{i&#x3D;1}y_{test}^{(i)}\log h_{\theta}(x^{(i)}_{test})+(1-y_{test}^{(i)})\log h_{\theta}(x^{(i)}_{test})$</li>
<li>错误分类误差（0&#x2F;1 misclassification erorr）：详见图。</li>
</ul>
</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/75.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="10-3-模型选择和交叉验证集"><a href="#10-3-模型选择和交叉验证集" class="headerlink" title="10.3 模型选择和交叉验证集"></a><span id="10.3">10.3 模型选择和交叉验证集</span></h3><p><em>如何评估学习算法：模型选择问题。</em></p>
<p><em>对于一个数据集，最合适的多项式次数如何确定；怎样选择合适的特征来构造学习算法；如何确定学习算法的正则化参数</em> $\lambda$</p>
<h4 id="模型选择Ⅰ"><a href="#模型选择Ⅰ" class="headerlink" title="模型选择Ⅰ"></a>模型选择Ⅰ</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/76.jpg'  width="80%" height="80%"/ loading="lazy">

<p>一种选择模型的方法：在多种特征的选择方法中，<strong>分别进行训练</strong>得出 $\Theta$，然后<strong>分别在测试集上进行测试</strong>，然后从这些模型中<strong>选出表现最好的一个</strong>（ $J_{test}(\Theta^{(i)})$ 最小）。</p>
<p>问题：判断这个模型的<strong>泛化能力</strong>如何？</p>
<p>我们可以观察这个假设模型对测试集的拟合情况，但问题是，这样做仍然不能公平地估计出这个假设的泛化能力。原因：参数 d 是多项式的次数（特征的维度），<strong>我们用测试集拟合了参数 d，选择了能够最好地拟合测试集的参数 d 的值</strong>。我们的参数向量 $\Theta$  在测试集上的性能很可能是对泛化误差过于乐观的估计。也就是说，<strong>测试集的误差 $J_{test}$ 让我们找出了最好的模型，但不能用同一个误差来衡量模型的泛化能力。</strong></p>
<h4 id="交叉验证集"><a href="#交叉验证集" class="headerlink" title="交叉验证集"></a>交叉验证集</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/77.jpg'  width="80%" height="80%"/ loading="lazy">

<p>将数据分为三部分：训练集60%（training set）、交叉验证集20%（cross validation set）和测试集20%（test set）。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/78.jpg'  width="80%" height="80%"/ loading="lazy">



<h4 id="模型选择Ⅱ"><a href="#模型选择Ⅱ" class="headerlink" title="模型选择Ⅱ"></a>模型选择Ⅱ</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/79.jpg'  width="80%" height="80%"/ loading="lazy">

<p>对于每种模型，训练出 $\Theta$，然后在<strong>交叉验证集</strong>上计算 $J_{cv}(\Theta)$，选择表现最好的参数 d，即选择某个模型。在<strong>测试集</strong>上进行误差的估计，计算  $J_{test}(\Theta)$，就可以用  $J_{test}(\Theta)$ 来衡量算法选出的模型的<strong>泛化能力</strong>了。 </p>
<h3 id="10-4-诊断偏差和方差（diagnosing-bias-vs-variance）"><a href="#10-4-诊断偏差和方差（diagnosing-bias-vs-variance）" class="headerlink" title="10.4 诊断偏差和方差（diagnosing bias vs. variance）"></a><span id="10.4">10.4 诊断偏差和方差（diagnosing bias vs. variance）</span></h3><p>当一个模型表现不好，主要有两种原因：高偏差（high bias，欠拟合）、高方差（high variance，过拟合）。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/80.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li><p>多项式次数小，训练集上表现不佳，bias高。</p>
</li>
<li><p>多项式次数高，训练集上拟合得好，bias低；但交叉验证集上会过拟合，variance高。</p>
</li>
</ul>
<h4 id="如何确定模型为何表现不佳？"><a href="#如何确定模型为何表现不佳？" class="headerlink" title="如何确定模型为何表现不佳？"></a>如何确定模型为何表现不佳？</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/81.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li>Bias（欠拟合）：<ul>
<li>训练集上表现不好，$J_{train}(\Theta)$ 高</li>
<li>交叉验证集上表现不好，$J_{cv}(\Theta)≈J_{train}(\Theta)$</li>
</ul>
</li>
<li>Variance（过拟合）：<ul>
<li>训练集上表现很好，$J_{train}(\Theta)$ 低</li>
<li>交叉验证集上表现不好，$J_{cv}(\Theta)&gt;&gt;J_{train}(\Theta)$</li>
</ul>
</li>
</ul>
<p><em>接下来：对 bias 和 variance 的进一步解释，以及确定问题后应采取怎样的措施。</em></p>
<h3 id="10-5-正则化和偏差-x2F-方差"><a href="#10-5-正则化和偏差-x2F-方差" class="headerlink" title="10.5  正则化和偏差&#x2F;方差"></a><span id="10.5">10.5  正则化和偏差&#x2F;方差</span></h3><p><strong>正则化的线性回归</strong>，$\lambda$ 不同会得到不同的结果。太大会造成 bias，太小会造成 variance。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/82.jpg'  width="80%" height="80%"/ loading="lazy">

<p><strong>我们的模型</strong>：</p>
<ul>
<li>训练模型的过程中，添加正则项，得到 $\Theta$ 。</li>
<li>评估模型的过程中，只计算偏差，不进行优化。不用添加正则项。</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/83.jpg'  width="80%" height="80%"/ loading="lazy">

<p> <strong>自动选择</strong> $\lambda$：</p>
<ul>
<li><p>选取一系列想要尝试的取值，对于每个 $\lambda$ 分别让 $J(\Theta)$ 取到最小值，获得 $\Theta$</p>
</li>
<li><p>在交叉验证集上评估它们。选择让 $J_{cv}(\Theta^{(i)})$ 取到最小值的 $\lambda$ 。</p>
</li>
<li><p>在测试集上测试这个模型的表现。</p>
</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/84.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>正则化的 bias&#x2F;variance：</strong></p>
<ul>
<li>$J_{train}$：$\lambda$ 小，过拟合，训练集误差小；$\lambda$ 大，欠拟合，训练集误差大。</li>
<li>$J_{cv}$：$\lambda$ 小，过拟合，交叉验证集误差大（模型扩展性差）；$\lambda$ 大，欠拟合，交叉验证集误差大。</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/85.jpg'  width="80%" height="80%"/ loading="lazy">

<p>取多个 $\lambda$ 值，绘制交叉验证集误差 $J_{cv}(\Theta)$ 的曲线。</p>
<p>在真实的数据集中，得到的曲线可能更乱，有很多的噪声。有时可以看出一个趋势，通过观察整个交叉验证误差曲线，手动或自动得出能使交叉验证误差最小的 “just right” 的 $\lambda$ 取值。</p>
<h3 id="10-6-诊断方法：学习曲线（learning-curves）"><a href="#10-6-诊断方法：学习曲线（learning-curves）" class="headerlink" title="10.6 诊断方法：学习曲线（learning curves）"></a><span id="10.6">10.6 诊断方法：学习曲线（learning curves）</span></h3><p>控制使用的训练样本数量，绘制小数据集的训练集误差、交叉验证集误差。</p>
<ul>
<li>$J_{train}$：当训练集很小，拟合起来比较容易。当训练集增大，误差就会增加。</li>
<li>$J_{cv}$：当训练集很小，模型泛化程度不会很好。使用大的训练集，模型会有更好的泛化表现。</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/86.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>high bias 的学习曲线：</strong></p>
<ul>
<li>m 很小，拟合程度好（$J_{train}$小），泛化能力差（$J_{cv}$大）。</li>
<li>m 变大，$J_{cv}$ 和 $J_{train}$ 逐渐接近。当欠拟合时，训练集和交叉验证集上的表现都比较高，数值上相似。</li>
<li><strong>结论：如果模型处在 high bias  的情形，选用更多的训练集数据对于改善算法的表现无益。</strong></li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/87.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>high variance 的学习曲线：</strong></p>
<ul>
<li>m 很小，拟合程度好（$J_{train}$小），泛化能力差（$J_{cv}$大）。</li>
<li>m 变大，拟合越来越难，但拟合程度也不错。泛化能力依然差。$J_{cv}$ 和 $J_{train}$ 逐渐接近。当欠拟合时，训练集和交叉验证集上的表现都比较高，数值上相似。</li>
<li><strong>结论：如果模型处在 high variance 的情形，选用更多的训练集数据，延长这两条曲线，$J_{cv}$ 和 $J_{train}$ 会逐渐接近。这对改善算法的表现是有好处的。</strong></li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/88.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="10-7-决定下一步做什么"><a href="#10-7-决定下一步做什么" class="headerlink" title="10.7 决定下一步做什么"></a><span id="10.7">10.7 决定下一步做什么</span></h3><p>回到<a href="#10.1">10.1</a>提出的改进方法：</p>
<table>
<thead>
<tr>
<th>改进方法</th>
<th>适用场合</th>
</tr>
</thead>
<tbody><tr>
<td>更多训练样本</td>
<td>high variance</td>
</tr>
<tr>
<td>更少特征</td>
<td>high variance</td>
</tr>
<tr>
<td>更多特征</td>
<td>high bias</td>
</tr>
<tr>
<td>更多多项式特征</td>
<td>high bias</td>
</tr>
<tr>
<td>增加 $\lambda$</td>
<td>high variance</td>
</tr>
<tr>
<td>减小 $\lambda$</td>
<td>high bias</td>
</tr>
</tbody></table>
<h4 id="跟神经网络的结合"><a href="#跟神经网络的结合" class="headerlink" title="跟神经网络的结合"></a>跟神经网络的结合</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/89.jpg'  width="80%" height="80%"/ loading="lazy">





<hr>
<h2 id="第十一章-机器学习系统设计-Machine-Learning-System-Design"><a href="#第十一章-机器学习系统设计-Machine-Learning-System-Design" class="headerlink" title="第十一章 机器学习系统设计(Machine Learning System Design)"></a>第十一章 机器学习系统设计(Machine Learning System Design)</h2><h3 id="11-1-确定优先执行的事情"><a href="#11-1-确定优先执行的事情" class="headerlink" title="11.1 确定优先执行的事情"></a><span id="11.1">11.1 确定优先执行的事情</span></h3><p>以垃圾邮件分类器为例：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/90.jpg'  width="80%" height="80%"/ loading="lazy">

<p>监督学习，x &#x3D; 邮件的特征，来表示一组词是否在邮件中出现。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/91.jpg'  width="80%" height="80%"/ loading="lazy">

<p>事实上，有时会随机决定去采用上面四种方法的其中一种。</p>
<h3 id="11-2-误差分析（error-analysis）"><a href="#11-2-误差分析（error-analysis）" class="headerlink" title="11.2 误差分析（error analysis）"></a><span id="11.2">11.2 误差分析（error analysis）</span></h3><p><em>在改进机器学习算法时，通常有很多不同的思想。通过误差分析，可以更系统地在众多方法中做出选择。</em></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/92.jpg'  width="80%" height="80%"/ loading="lazy">

<p>当在面对一个机器学习问题时，最好花很少的时间，<strong>先通过一个简单的算法，快速实现出来</strong>，而不是设计一个很复杂的系统。然后<strong>用交叉验证集来测试数据</strong>，画出学习曲线，进行检验误差，来确定模型是否存在高偏差或者高方差的问题，或其他问题。然后再决定是否要用更多的数据或者特征等。</p>
<p>可以把这种思想想成：在编程时避免出现过早优化的问题，我们应当<strong>用实际的证据来指导我们的决策</strong>，来决定把时间花在哪里，而不是仅凭直觉。</p>
<h4 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h4><p>误差分析：可以<strong>人工检查算法出错的地方</strong>，查看被分错了的邮件有什么共同的特征和规律。这个过程可 以启发我们怎样设计新特征，或告诉我们现有系统的优点和缺点。</p>
 <img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/93.jpg'  width="80%" height="80%"/ loading="lazy">

<h4 id="量化指标"><a href="#量化指标" class="headerlink" title="量化指标"></a>量化指标</h4><p>如果算法能够返回一个<strong>数值指标</strong>，来估计算法执行的效果，将会很有帮助。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/94.jpg'  width="80%" height="80%"/ loading="lazy">

<p>是否使用词干提取（stemming）？使用了会造成一些问题，不使用会忽略一些情况。</p>
<p>这时就可以使用<strong>交叉验证集上的错误率</strong>作为数值指标，来决定是否使用词干提取。</p>
<p>在此基础上，要不要区分大小写？也可以通过这个单一量化指标来轻松决定。</p>
<p><strong>注意：不要再测试集上做误差分析。要在交叉验证集上做误差分析。</strong></p>
<p><strong>注意：最先实现的算法，简单粗暴为主，快是第一指标，再烂都没问题。</strong></p>
<h3 id="11-3-类偏斜的误差度量（error-metrics-for-skewed-classes）"><a href="#11-3-类偏斜的误差度量（error-metrics-for-skewed-classes）" class="headerlink" title="11.3 类偏斜的误差度量（error metrics for skewed classes）"></a><span id="11.3">11.3 类偏斜的误差度量（error metrics for skewed classes）</span></h3><p>上节提到了误差分析和设定误差度量值的重要性，那就是设定某个实数来评估学习算法并衡量它的表现。但仅用准确率accuracy来评价模型，在一种条件下是不可靠的，这个问题就是偏斜类的问题。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/95.jpg'  width="80%" height="80%"/ loading="lazy">

<p>正样本的数量与负样本的数量相比，非常非常少，这种情况就叫偏斜类（skewed classes）。</p>
<p>精确度从99.2%提升到99.5%，不能说分类模型的质量提升了，因为有时模型恒定输出0，如果样本中y&#x3D;0的比率比模型的预测准确率高，也能带来数值上的提升。</p>
<p>对于偏斜类，需要有不同的误差度量值：</p>
<p><strong>查准率和查全率</strong></p>
<ul>
<li><strong>precision：查准率、精确率</strong>。在预测为1的样本中，有多少是预测正确的？（没错诊）</li>
<li><strong>recall：查全率、召回率</strong>。在真实为1的样本中，有多少是预测出来的？（没漏诊）</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/96.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="11-4-查准率和查全率之间的权衡（trading-off-precision-and-recall）"><a href="#11-4-查准率和查全率之间的权衡（trading-off-precision-and-recall）" class="headerlink" title="11.4 查准率和查全率之间的权衡（trading off precision and recall）"></a><span id="11.4">11.4 查准率和查全率之间的权衡（trading off precision and recall）</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/97.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li><p>给没有病的人通知得病是不好的。为了提高precision，也就是降低误诊率，可以把逻辑回归的阈值设置得高一些。</p>
<p>这会导致：higher precision（有更高的把我才预测得病），lower recall（容易漏诊）</p>
</li>
<li><p>没有给得病的人通知也是不好的。为了提高recall，也就是降低漏诊率，可以把逻辑回归的阈值设置得低一些。</p>
<p>这会导致：higher recall（有病的人容易被预测到），lower precision（没病的人也容易被预测到）。</p>
</li>
</ul>
<p>问题来了：有没有办法自动选取阈值？more generally，如果我们有不同的算法，如何比较不同的查准率和查全率？</p>
<p>在<a href="#10.2">10.2</a>，我们提出设置单个数值指标来评估模型的好坏。但现在我们有两个可以判断的数字 precision 和 recall。如何得到单个数值？</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/98.jpg'  width="80%" height="80%"/ loading="lazy">

<p>平均值是不行的。比如图中 Algorithm 3，恒输出y&#x3D;1，显然不是一个好模型。</p>
<p>F<sub>1</sub> 值（调和平均值）共同考虑了两个值，并且给小的值更高的权重。</p>
<h3 id="11-5-机器学习的数据"><a href="#11-5-机器学习的数据" class="headerlink" title="11.5 机器学习的数据"></a><span id="11.5">11.5 机器学习的数据</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/99.jpg'  width="80%" height="80%"/ loading="lazy">

<p>实验证明：给算法更多的数据，模型的性能往往会变好。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/100.jpg'  width="80%" height="80%"/ loading="lazy">

<p>如何判断 feature x 是否包含了充足的信息，能够从中预测出 y？</p>
<p>判别方式：找一个人类专家，他能根据现有条件给出预测吗？</p>
<p>一个说英语的人，可以根据现有上下文填出 “two”；但一个房地产专家不能仅根据房屋面积预测房价。</p>
<p><strong>如果 feature x 确实包含了充足的的信息用来预测 y ，大量的训练数据就是有帮助的。</strong></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/101.jpg'  width="80%" height="80%"/ loading="lazy">

<p>使用一个有很多参数的学习算法（也被直接称为 low bias algorithm），在训练集上会得到不错的拟合效果，也就是 $J_{train}$ 比较小。</p>
<p>然后，用一个很大的训练集进行训练，模型就难以过拟合（low variance），在测试集上表现跟训练集上差不多，也就是 $J_{train}≈J_{test}$。</p>
<p>也就是：$J_{test}$ 比较小。</p>
<p>以上，我们证明了：做一个关键的假设<strong>如果特征值有足够的信息量，并有一类很好的学习算法保证low bias，那么——如果由大量的训练数据集，这能保证得到 low variance 的模型</strong>。</p>
<hr>
<h2 id="第十二章-支持向量机-Support-Vector-Machines）"><a href="#第十二章-支持向量机-Support-Vector-Machines）" class="headerlink" title="第十二章 支持向量机(Support Vector Machines）"></a>第十二章 支持向量机(Support Vector Machines）</h2><p>在监督学习中， 很多监督学习算法的性能都很相似，所以经常要考虑的不是选择哪种算法，而是：构建算法时所使用的数据量。这体现了应用算法时的技巧，比如所涉及的用于学习算法的特征的选择，以及正则化参数的选择，等等。</p>
<p>还有一个更加强大的算法，有广泛的应用：支持向量机（support vector machine）。与逻辑回归、神经网络相比，SVM在学习复杂的非线性方程时，能提供一种更为清晰和更强大的方式。</p>
<h3 id="12-1-优化目标（optimization-objective）"><a href="#12-1-优化目标（optimization-objective）" class="headerlink" title="12.1 优化目标（optimization objective）"></a><span id="12.1">12.1 优化目标（optimization objective）</span></h3><h4 id="从逻辑回归的损失函数定义SVM的损失函数"><a href="#从逻辑回归的损失函数定义SVM的损失函数" class="headerlink" title="从逻辑回归的损失函数定义SVM的损失函数"></a>从逻辑回归的损失函数定义SVM的损失函数</h4><p><strong>直观上</strong>：以直代曲。</p>
<p>跟逻辑回归的代价函数中的取对数部分相似，当 y&#x3D;1，$cost_1(z)$ 让 z 越大越好；当 y&#x3D;0，$cost_0(z)$ 让 z 越小越好。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/102.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>表达式上：</strong></p>
<ul>
<li>把取对数项换成 $cost_1(z)$ 和 $cost_0(z)$ </li>
<li>去掉 $\frac{1}{m}$ （约定习惯。优化的结果不会变，依然是最佳值）</li>
<li>逻辑回归的损失函数形式上是 $A+\lambda B$，用 $\lambda$ 来权衡损失 $A$ 和正则化 $B$ 的相对权重（来决定我们是更关心第一项还是第二项的优化）。而在SVM里，使用 $CA+B$ 的形式，对 $C$ 赋值来权衡 $A$ 、$B$ 的相对权重。可以理解为$C &#x3D; \frac{1}{\lambda}$。</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/103.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="12-2-大边界的直观理解（large-margin-intuition）"><a href="#12-2-大边界的直观理解（large-margin-intuition）" class="headerlink" title="12.2 大边界的直观理解（large margin intuition）"></a><span id="12.2">12.2 大边界的直观理解（large margin intuition）</span></h3><p>有时候称 SVM 为大间距分类器（large margin classifier）。</p>
<p>从损失函数图像理解：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/104.jpg'  width="80%" height="80%"/ loading="lazy">

<p>从损失函数表达式理解：</p>
<p>当 $C$ 取一个很大的值，在优化过程中我们希望让第一项为0。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/105.jpg'  width="80%" height="80%"/ loading="lazy">

<p>逻辑回归：当$y&#x3D;1$，我们希望 $z≥0$；当$y&#x3D;0$，我们希望 $z&lt;0$。</p>
<p><strong>SVM：当$y&#x3D;1$，我们希望 $z≥1$；当$y&#x3D;0$，我们希望 $z≤-1$。</strong></p>
<p>SVM的决策边界：SVM会尽量把正样本和负样本以最大的间距分开。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/106.jpg'  width="70%" height="70%"/ loading="lazy">



<p>一个问题：只因为一个负样本分布比较偏，预测边界就从黑线转变为紫线，是不合理的。但如果把 <strong>SVM 的 $C$ 设置得非常大</strong>，因此会做这样的转变。</p>
<p><strong>如果 $C$ 不是很大，或者模型本身不是线性可分的</strong>，那就不会有这样的问题。预测边界是黑线，SVM表现不错。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/107.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="12-3-大边界分类器背后的数学原理"><a href="#12-3-大边界分类器背后的数学原理" class="headerlink" title="12.3 大边界分类器背后的数学原理*"></a><span id="12.3">12.3 大边界分类器背后的数学原理*</span></h3><p><em>SVM的优化问题和大间距分类器之间的联系</em></p>
<p><strong>回顾向量内积</strong>：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/108.jpg'  width="80%" height="80%"/ loading="lazy">

<p>$u^T v &#x3D; p·||u|| &#x3D; u_1v_1+u_2v_2，$p 是 $v$ 投影到 $u$ 上的长度。</p>
<p><strong>SVM 决策边界</strong>：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/109.jpg'  width="80%" height="80%"/ loading="lazy">

<p>SVM 损失函数第二项，优化时，做的其实是最小化参数向量 $\theta$ 的范数（长度）的平方。</p>
<p>$\theta^Tx^{(i)}&#x3D;p^{(i)}·||\theta||&#x3D;\theta_1x_1^{(i)}+\theta_2x_2^{(i)}$</p>
<p>上式告诉我们：两个条件 $\theta^Tx^{(i)} ≥1$、$\theta^Tx^{(i)} ≤1$ 可以换种方式表述，即 $ p^{(i)}·||\theta||$ 的大小。</p>
<p>改写后：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/110.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li>假设 $\theta_0&#x3D;0$ ，决策边界通过原点，决策边界一定与 $\theta$ 向量垂直。以 $\theta_1x_1+\theta_2x_2≥1$ 为例，$x_2 &#x3D; -\frac{\theta1}{\theta2} x_1 + a$ ，跟 $\theta$ （斜率 $\frac{\theta_2}{\theta_1}$）是垂直的。</li>
<li>左图绿色的决策边界，会导致 $x$ 到 $\theta$ 的投影长度较小。我们又要求 $ p^{(i)}·||\theta||≥1$ ，因此 $\theta$ 的范数要比较大。</li>
<li>右边绿色的决策边界，会导致 $x$ 到 $\theta$ 的投影长度比较大。要求 $ p^{(i)}·||\theta||≥1$ ，可以把 $\theta$ 优化到很小。</li>
<li>在SVM中，要求对于大多数数据点， $\theta^Tx ≥1$，也就是说，正样本、负样本的数据点投影到 $\theta$ 的值足够大，就是使决策边界周围保持大间距，让 $p^{(i)}$ 尽量大。</li>
</ul>
<h3 id="12-4-核函数Ⅰ"><a href="#12-4-核函数Ⅰ" class="headerlink" title="12.4 核函数Ⅰ"></a><span id="12.4">12.4 核函数Ⅰ</span></h3><p><em>改造 SVM，来构造复杂的非线性分类器</em></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/111.jpg'  width="80%" height="80%"/ loading="lazy">

<p>非线性决策边界的拟合，需要很多的高阶多项式项，给计算带来麻烦。</p>
<h4 id="是否有更好的特征选择方式？"><a href="#是否有更好的特征选择方式？" class="headerlink" title="是否有更好的特征选择方式？"></a>是否有更好的特征选择方式？</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/112.jpg'  width="80%" height="80%"/ loading="lazy">

<p>每个特征是 x 与 l 的相似度 $f_i &#x3D; similarity(x, l^{(i)}) &#x3D; exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2})$</p>
<p>这个相似度函数 similarity(x, l) 就是核函数，在这里是高斯核函数。</p>
<p>相似度函数（核函数）的作用：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/112.jpg'  width="80%" height="80%"/ loading="lazy">

<p>这些特征 f 的作用就是衡量 x 到 l 的相似度。越相近，f 越接近 1；越不相近，f 越接近 0.</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/114.jpg'  width="80%" height="80%"/ loading="lazy">

<p>$\sigma$ 越大，从把 x 从 l 点移走时，特征变量的值 f 下降得越慢。</p>
<h4 id="从特征到预测函数"><a href="#从特征到预测函数" class="headerlink" title="从特征到预测函数"></a>从特征到预测函数</h4><p>通过前面的核函数，可以从 x 得到特征 f 了，并且越接近 f<sub>i</sub> 对应的 l<sub>i</sub> ，f<sub>i</sub> 的输出越接近1。</p>
<p>通过学习到每个特征对应的 $\theta$，就可以进行预测，拟合复杂的非线性边界了。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/115.jpg'  width="80%" height="80%"/ loading="lazy">

<p>以图中的 $\theta$ 取值为例，接近 $l_1,l_2$ 的点，预测的结果为 1；远离 $l_1,l_2$ 的点，预测的结果为 0.</p>
<p>现在已经学习了核函数，以及如何在 SVM 使用核函数，来定义新的特征变量了。</p>
<p>还有一些问题：如何选择标记点 $l$？其他的核函数（相似度函数）是什么样的？</p>
<h3 id="12-5-核函数Ⅱ"><a href="#12-5-核函数Ⅱ" class="headerlink" title="12.5 核函数Ⅱ"></a><span id="12.5">12.5 核函数Ⅱ</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/116.jpg'  width="80%" height="80%"/ loading="lazy">

<h4 id="如何选择-landmarks？"><a href="#如何选择-landmarks？" class="headerlink" title="如何选择 landmarks？"></a>如何选择 landmarks？</h4><p>一种方法：把数据集的 m 个样本都选择为 landmarks，即 $l^{(i)}&#x3D;x^{(i)}$。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/117.jpg'  width="80%" height="80%"/ loading="lazy">

<p>如上图对于每个输入 x，把它转换成一个 m 维的特征向量 $f^{(i)}$.</p>
<h4 id="SVM-的训练"><a href="#SVM-的训练" class="headerlink" title="SVM 的训练"></a>SVM 的训练</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/118.jpg'  width="80%" height="80%"/ loading="lazy">

<p>注意：</p>
<ul>
<li><p>在优化时设置 $\theta^Tf≥1$ ，在预测时用 $\theta^Tf≥0$</p>
</li>
<li><p>忽略掉 $\theta_0$后，最后一项正则化也可以用 $\theta^T\theta$ 来计算。</p>
</li>
<li><p>由于所有样本都设置为关键点，有 m &#x3D; n，正则化项求和边界没变。</p>
</li>
<li><p>在逻辑回归等算法也可以采用核函数的思想，来设置关键点，但在计算上没有 SVM 特有的优化方法。</p>
</li>
<li><p>这个函数的优化不建议自己实现，调包即可。</p>
</li>
</ul>
<h4 id="SVM-的参数，偏差和方差"><a href="#SVM-的参数，偏差和方差" class="headerlink" title="SVM 的参数，偏差和方差"></a>SVM 的参数，偏差和方差</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/119.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li>C（理解为 $\frac{1}{\lambda}$)<ul>
<li>C 大：拟合项权重大，正则化项权重小，容易过拟合。low bias, high variance。</li>
<li>C 小：拟合项权重小，正则化项权重大，容易欠拟合。high bias, low variance。</li>
</ul>
</li>
<li>$\sigma^2$<ul>
<li>$\sigma^2$ 大：$f$ 平缓，模型随x的改变，变化不明显，容易欠拟合。high bias, low variance。</li>
<li>$\sigma^2$ 小：$f $ 陡峭，变化明显，容易过拟合。low bias, high variance。</li>
</ul>
</li>
</ul>
<h3 id="12-6-使用支持向量机"><a href="#12-6-使用支持向量机" class="headerlink" title="12.6 使用支持向量机"></a><span id="12.6">12.6 使用支持向量机</span></h3><p><strong>不需要自己写 SVM 优化软件，但需要手动</strong>：</p>
<ul>
<li>选择参数 C</li>
<li>选择核函数<ul>
<li>无核函数（也叫线性核函数）<ul>
<li>predict “y &#x3D; 1” if $\theta^Tx≥0$ </li>
<li>线性关系（$\theta_0+\theta_1x_1+…+\theta_nx_n≥0$)</li>
<li>如果有大量的特征值和很少的训练数据集（n大，m小），就拟合一个线性的判定边界，而不去你和一个非常复杂的非线性函数，防止过拟合</li>
</ul>
</li>
<li>高斯核函数<ul>
<li>$f_i &#x3D; exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2})$，where $l^{(i)} &#x3D; x^{(i)}$</li>
<li>选择参数 $\sigma^2$ </li>
<li>如果特征值少，训练集数据多（n小，m大），用高斯核函数是一个好的选择</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/120.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>核函数的编写</strong>：</p>
<ul>
<li>很多 SVM 优化函数需要核函数作为参数传入</li>
<li>核函数返回一个实数</li>
<li>在使用高斯核函数前需要做 feature scaling</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/121.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>核函数的选择</strong>：</p>
<ul>
<li>核函数需要通过 mercer’s theorem 检查，确保能够正常优化</li>
<li>其他的核函数<ul>
<li>多项式核函数（Polynomial kernal）<ul>
<li>$k(x, l) &#x3D; (x^Tl+constant)^{degree}$ </li>
<li>通常用在 x 和 l 都是严格的非负数时，以确保内积一定不是负数</li>
</ul>
</li>
<li>string kernel, chi-square kernal, histogram intersection kernel, …</li>
</ul>
</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/122.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>多分类任务</strong>：</p>
<ul>
<li>很多包都内置了多分类 SVM 功能</li>
<li>如果没有，使用 one-vs-all 思想（见<a href="#6.7">6.7</a>）：如果有 k 个类别，就训练 k 个 SVM ，用以将每个类别从其他的类别中区分开来。会得到 k 组 $\theta$，预测时取最大值的索引作为分类结果。</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/123.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>逻辑回归 vs SVMs</strong>：</p>
<p>n 是特征的个数（$x∈\R^{n+1}$），m 是训练集样本个数</p>
<ul>
<li>n 比 m 大很多（如有10000个词特征，只有1000篇邮件来训练）：<strong>使用逻辑回归或无核函数（线性核函数）</strong></li>
<li>n 很小，m 大小适中（n&#x3D;1~1000，m&#x3D;10~10000)：<strong>高斯核函数表现好</strong></li>
<li>n 很小，m 很大（n&#x3D;1~1000，m&#x3D;~50000+）：高斯核函数会跑的很慢。如果训练样本特别多，<strong>尝试添加更多特征，然后使用逻辑回归或无核函数（线性核函数）</strong></li>
</ul>
<p><strong>在所有的场合，设计良好神经网络都可以表现的很好</strong>。缺点是比起好的SVM包，神经网络训练得比较慢。在实际应用中，对于神经网络，局部最优是一个不大不小的问题；但SVM的优化是凸函数优化，在使用SVM时不需要担心这个问题。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/124.jpg'  width="80%" height="80%"/ loading="lazy">





<hr>
<h2 id="第十三章-聚类-Clustering）"><a href="#第十三章-聚类-Clustering）" class="headerlink" title="第十三章 聚类(Clustering）"></a>第十三章 聚类(Clustering）</h2><h3 id="13-1-无监督学习简介（unsupervised-learning-introduction）"><a href="#13-1-无监督学习简介（unsupervised-learning-introduction）" class="headerlink" title="13.1 无监督学习简介（unsupervised learning introduction）"></a><span id="13.1">13.1 无监督学习简介（unsupervised learning introduction）</span></h3><p>监督学习：我们有一系列标签，然后用假设函数去拟合它。</p>
<p>无监督学习：我们的数据并不带有任何的标签。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/125.jpg'  width="90%" height="90%"/ loading="lazy">



<p>聚类算法的应用：</p>
<ul>
<li>市场分割</li>
<li>社交网络分析</li>
<li>组指计算机集群</li>
<li>天文数据分析</li>
</ul>
<h3 id="13-2-K均值算法（K-means-algorithm）"><a href="#13-2-K均值算法（K-means-algorithm）" class="headerlink" title="13.2 K均值算法（K-means algorithm）"></a><span id="13.2">13.2 K均值算法（K-means algorithm）</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/126.jpg'  width="90%" height="90%"/ loading="lazy">

<p>输入：</p>
<ul>
<li>K：聚类的个数</li>
<li>训练数据集 ${x^{(1)},x^{(2)},…,x^{(m)}}$ <ul>
<li>$x^{(i)}∈\R^n$，<strong>无监督学习的x是 n 维向量而不是 n+1 维</strong></li>
</ul>
</li>
</ul>
<p><strong>随机初始化 K 个聚类中心</strong> $\mu_1, \mu_2,…,\mu_k ∈ \R^K$</p>
<p>循环：</p>
<ul>
<li>样本划分：对于每个训练集的样本，<strong>把值设置为最接近的聚类中心的值</strong></li>
<li>移动聚类中心：对于每个聚类中心，<strong>把所有值相同的训练样本求平均，得到新的聚类中心</strong><ul>
<li>如果有聚类中心没有一个训练样本，常见的做法是移除这个聚类中心</li>
</ul>
</li>
</ul>
<p>即使数据没有明确分为几簇，K-means算法还是能将数据分为几个簇。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/127.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="13-3-优化目标（optimization-objective）"><a href="#13-3-优化目标（optimization-objective）" class="headerlink" title="13.3 优化目标（optimization objective）"></a><span id="13.3">13.3 优化目标（optimization objective）</span></h3><p>了解K-means的优化函数，能帮助我们：</p>
<ul>
<li>对学习算法进行调试，确保算法正确运行</li>
<li>帮助算法找到更好的簇，并避免局部最优解（下节讲）</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/128.jpg'  width="80%" height="80%"/ loading="lazy">

<p>K-means算法的代价函数：训练样本到聚类中心的接近程度</p>
<p>K-means算法的优化目标：调整聚类中心 $\mu$ 、样本划分 $c$ ，让代价函数取到最小值</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/129.jpg'  width="80%" height="80%"/ loading="lazy">

<p>每次迭代：</p>
<ul>
<li><p>先样本划分：改变 $c^{(i)}$，不改变 $\mu_k$，优化代价函数 $J$ 关于变量 $c$</p>
</li>
<li><p>后移动聚类中心：改变 $\mu_k$，优化代价函数 $J$ 关于变量 $\mu$</p>
</li>
</ul>
<h3 id="13-4-随机初始化（random-initialization）"><a href="#13-4-随机初始化（random-initialization）" class="headerlink" title="13.4 随机初始化（random initialization）"></a><span id="13.4">13.4 随机初始化（random initialization）</span></h3><p><em>如何初始化 K-means、如何使 K-means 避开局部最优</em></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/130.jpg'  width="80%" height="80%"/ loading="lazy">

<p>从 $x^{(i)}$ 里随机找 K 个聚类中心，这就是随机初始化。随机初始化状态不同，K-means最后可能会得到不同的结果。特别地，K-means 可能会落在局部最优。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/131.jpg'  width="80%" height="80%"/ loading="lazy">

<p>我们可以以不同的初始值初始化 K-means 很多次，并执行算法很多次，以此来保证我们最终能得到一个尽可能好的局部或全局最优值。</p>
<p>具体做法如下：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/132.jpg'  width="80%" height="80%"/ loading="lazy">

<p>多次随机初始化 K-means 算法，分别求代价函数，在其中找最小的 $J$ .当 K 不是特别大（不超过10），一般都能得到比较好的结果。</p>
<h3 id="13-5-选择聚类个数K（choosing-the-number-of-clusters）"><a href="#13-5-选择聚类个数K（choosing-the-number-of-clusters）" class="headerlink" title="13.5 选择聚类个数K（choosing the number of clusters）"></a><span id="13.5">13.5 选择聚类个数K（choosing the number of clusters）</span></h3><p>这个问题没有什么好的答案，也没有能自动处理的方法。用来决定聚类数量最常用的方法仍然是：人工，人为观察可视化的图，或者观察聚类算法的输出。</p>
<p>无监督学习没有给出标签，因此并不总是有一个明确的答案。也是因为这个原因，用算法自动选择聚类个数是困难的。</p>
<p><strong>肘部法则（elbow method）</strong>：改变 K 的值，计算损失函数 $J$，选择“elbow”的点作为 K 的个数。（每次计算 $J$ 都要随机取个100次的初始聚类中心，这个计算消耗是不小的。）有时这个肘部也不太好找。总之：这是个值得尝试的方法，但不能指望它解决问题。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/133.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>从下游找K值：</strong>聚类往往是要解决问题的，比如T恤分为 S、M、L 三个聚类，从类似的下游环节寻找聚类个数。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/134.jpg'  width="80%" height="80%"/ loading="lazy">






<hr>
<h2 id="第十四章-降维-Dimensionality-Reduction）"><a href="#第十四章-降维-Dimensionality-Reduction）" class="headerlink" title="第十四章 降维(Dimensionality Reduction）"></a>第十四章 降维(Dimensionality Reduction）</h2><h3 id="14-1-动机一：数据压缩（data-compression）"><a href="#14-1-动机一：数据压缩（data-compression）" class="headerlink" title="14.1 动机一：数据压缩（data compression）"></a><span id="14.1">14.1 动机一：数据压缩（data compression）</span></h3><p>数据压缩不仅能让我们节省存储空间，还能对学习算法进行加速。</p>
<p>我们需要一个二维向量 $x^{(i)}∈\R^2$ 来表示一个样本的两个特征值。有时候这两个特征是冗余的，特征值可能是线性的。</p>
<p>如果能通过投影绿线上的样本来近似原始的数据集，那只需要一个实数 $z^{(i)}∈\R $ 就能指定点在直线上的位置。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/135.jpg'  width="80%" height="80%"/ loading="lazy">

<p>从 3D 到 2D 的降维也是一样的：三维中的数据大概都分布在一个平面内，所以我们通过把所有数据都投影到一个二维平面上来进行降维。</p>
<p>这样，使用二维向量 $z^{(i)}∈\R^2$ 可以表示三维坐标。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/136.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="14-2-动机二：数据可视化（data-visualization）"><a href="#14-2-动机二：数据可视化（data-visualization）" class="headerlink" title="14.2 动机二：数据可视化（data visualization）"></a><span id="14.2">14.2 动机二：数据可视化（data visualization）</span></h3><p>数据可视化可以帮助我们理解数据。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/137.jpg'  width="80%" height="80%"/ loading="lazy">



<p>以图中50维的国家数据为例，如果能只用两个数字，来概述50个数字，就可以把这些国家在二维平面上表示出来。</p>
<p>当观察降维算法的输出时，z 通常不是所期望的具有物理意义的特征，我们常常要弄清楚这些特征大致意味着什么。</p>
<p>比如图中，横轴表示国家的“体量”，纵轴表示国家的“人均”。</p>
<h3 id="14-3-主成分分析问题（principal-component-analysis-problem-formulation）"><a href="#14-3-主成分分析问题（principal-component-analysis-problem-formulation）" class="headerlink" title="14.3 主成分分析问题（principal component analysis problem formulation）"></a><span id="14.3">14.3 主成分分析问题（principal component analysis problem formulation）</span></h3><p>主成分分析算法（PCA）是很常用、很流行的降维算法。</p>
<h4 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/138.jpg'  width="80%" height="80%"/ loading="lazy">



<p>PCA算法会找一个低维平面（图中红线），然后将数据投影在上面，使数据到低维平面的距离最小（图中蓝色小线段）。</p>
<p>更正式地说：当从n维降到k维，需要找出一个方向（找出k个向量 $u^{(i)}∈\R^n$，定义这个k维空间）。PCA能够找出最小化投影距离的方式，来对数据进行投影。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/139.jpg'  width="80%" height="80%"/ loading="lazy">



<h4 id="PCA和线性回归"><a href="#PCA和线性回归" class="headerlink" title="PCA和线性回归"></a>PCA和线性回归</h4><p>PCA和lr看上去相似，但确实是两种完全不同的算法。</p>
<p>线性回归：最小化预测值和实际值的距离。用x预测y。</p>
<p>PCA：最小化投影距离（正交距离）。都是特征x，没有需要特殊对待的y。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/140.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="14-4-主成分分析算法（principal-component-analysis-algorithm）"><a href="#14-4-主成分分析算法（principal-component-analysis-algorithm）" class="headerlink" title="14.4 主成分分析算法（principal component analysis algorithm）"></a><span id="14.4">14.4 主成分分析算法（principal component analysis algorithm）</span></h3><p>首先要进行 feature scaling、mean normalization 等数据预处理工作。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/141.jpg'  width="80%" height="80%"/ loading="lazy">

<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/142.jpg'  width="80%" height="80%"/ loading="lazy">



<p><strong>PCA 算法需要做的两件事：求出定义了降维空间的向量 $u$；求出样本在降维空间的投影 $z$。</strong></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/143.jpg'  width="80%" height="80%"/ loading="lazy">

<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/144.jpg'  width="80%" height="80%"/ loading="lazy">

<p>PCA算法：</p>
<p>先计算协方差矩阵 $\Sigma$，再计算 $\Sigma$ 的特征向量 $U$.</p>
<p>$U$ 是 (n, n) 维矩阵，它的前 $k$ 列就是要求的 k 维空间的方向向量 $u^{(1)}, u^{(2)}, …,u^{(k)}$ 。</p>
<p>把这些向量$u^{(1)}, u^{(2)}, …,u^{(k)}$ 构建成 $U_{reduce}$ 矩阵 (n, k)维，通过公式 $z &#x3D; U_{reduce}^TX$ 可以求的 k 维空间的样本 $z$ 。</p>
<p>PCA算法总览：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/145.jpg'  width="80%" height="80%"/ loading="lazy">



<p>本节没有给出数学上详细的证明，来证明 $u$、$z$ 就是让误差平方最小的投影方法。</p>
<h3 id="14-5-选择主成分的数量（choosing-the-number-of-principal-components）"><a href="#14-5-选择主成分的数量（choosing-the-number-of-principal-components）" class="headerlink" title="14.5 选择主成分的数量（choosing the number of  principal components）"></a><span id="14.5">14.5 选择主成分的数量（choosing the number of  principal components）</span></h3><p>本节将讨论如何选择降维后的维度 k。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/146.jpg'  width="80%" height="80%"/ loading="lazy">

<p>投影误差可以理解为放弃的特征值，总方差理解为全部的特征值。</p>
<p>选择k的通用原则是：选择使不等式成立的最小k。</p>
<p>意思是：保留更多的方差。</p>
<p>找k的算法的实现如下，可以使用 <code>svd(Sigma)</code> 返回的S来简化计算。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/147.jpg'  width="80%" height="80%"/ loading="lazy">

<p>只需要运行svd函数一次，就可以进行这些运算。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/148.jpg'  width="80%" height="80%"/ loading="lazy">

<p>$\frac{\sum^k_{i&#x3D;1}S_{ii}}{\sum^m_{i&#x3D;1}S_{ii}}≥0.99$这个式子也可以用来表示 k 值选的好不好。如果我们把特征从1000维降到100维，可以使用这个不等式来衡量降维对于特征保留的性能。</p>
<h3 id="14-6-降维重建（reconstruction-from-compressed-representation）"><a href="#14-6-降维重建（reconstruction-from-compressed-representation）" class="headerlink" title="14.6 降维重建（reconstruction from compressed representation）"></a><span id="14.6">14.6 降维重建（reconstruction from compressed representation）</span></h3><p>怎样从 $z∈\R$ 得到 $x∈\R^2$？</p>
<p>求$z$的公式是 $z&#x3D;U_{reduce}^Tx$，$U$不是方阵，没有逆矩阵，不能直接算。 $x_{approx}&#x3D;U_{reduce}z$。由于PCA要求投影不能跟数据点离得太远，所以 $x_{approx}$ 差不多就是 $x$。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/149.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="14-7-主成分分析法的应用建议（advice-for-applying-PCA）"><a href="#14-7-主成分分析法的应用建议（advice-for-applying-PCA）" class="headerlink" title="14.7 主成分分析法的应用建议（advice for applying PCA）"></a><span id="14.7">14.7 主成分分析法的应用建议（advice for applying PCA）</span></h3><p><em>PCA是如何提高算法执行效率的？</em></p>
<h4 id="应用PCA的注意事项"><a href="#应用PCA的注意事项" class="headerlink" title="应用PCA的注意事项"></a>应用PCA的注意事项</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/150.jpg'  width="80%" height="80%"/ loading="lazy">

<p>PCA建立了从 $x$ 到 $z$ 的映射关系，这个映射关系只能通过<strong>在训练集上运行PCA</strong>得到。</p>
<p>这个映射所做的就是计算一系列参数，比如进行特征缩放和均值归一化，还计算了$U_{reduce}$，找到合适的k值等。我们<strong>应该只在训练集上拟合这些参数</strong>，而不知交叉验证集或测试集上。</p>
<p>在训练集上找到所有参数后，就可以把这个映射用在交叉验证集或测试集的其他样本中。</p>
<p>以图中为例，<strong>只在训练集的数据上运行PCA</strong>，从 $x$ 到 $z$ 建立映射，然后在 $z$ 和 $y$ 之间拟合机器学习算法（<strong>低维数据提高了算法的运行效率</strong>），当要做预测时，就把交叉验证集和测试集中的数据也映射为 $z$（映射用的矩阵 $U_{reduce}$也<strong>只能从训练集得来</strong>），然后通过机器学习算法得出预测结果。</p>
<h4 id="PCA的应用场景"><a href="#PCA的应用场景" class="headerlink" title="PCA的应用场景"></a>PCA的应用场景</h4><p><strong>PCA的主要应用场景：</strong></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/151.jpg'  width="80%" height="80%"/ loading="lazy">

<p>不同的应用场景要选择不同的k值。</p>
<p><strong>PCA的错误应用场景：</strong></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/152.jpg'  width="80%" height="80%"/ loading="lazy">

<p>PCA能给数据降维，减少特征数量。所以有人会认为PCA可以用来防止过拟合。</p>
<p>如果这样做了，可能效果也会很好，但这不是解决过拟合的好方法。更好的解决过拟合的方法是：使用正则化。</p>
<p>原因：PCA不使用标签y，仅使用输入的x，去寻找接近的低维数据。PCA扔掉一些信息来减少数据的维度，并且不关心y的值。PCA更有可能丢失一些有价值的信息。</p>
<p><strong>PCA的另一个误用：</strong></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/153.jpg'  width="80%" height="80%"/ loading="lazy">

<p>经常在一个项目开始时，一些人会写一个项目计划，其中包括PCA在内的四步。</p>
<p>在写下这样的计划之前，要先问这个问题：如何直接去做而不使用PCA会怎样？</p>
<p>只有在使用原始数据 $x^{(i)}$ 达不到预期效果时（运行太慢，需要提高效率；内存不够、硬盘不够，需要压缩数据），才考虑使用PCA和 $z^{(i)}$。</p>
<hr>
<h2 id="第十五章-异常检测-Anomaly-Detection）"><a href="#第十五章-异常检测-Anomaly-Detection）" class="headerlink" title="第十五章 异常检测(Anomaly Detection）"></a>第十五章 异常检测(Anomaly Detection）</h2><p>这是机器学习算法的一个常见应用，它的有趣之处在于：虽然主要用在非监督学习问题，但从某个角度看，跟有监督学习问题是非常相似的。</p>
<h3 id="15-1-问题的动机（problem-motivation）"><a href="#15-1-问题的动机（problem-motivation）" class="headerlink" title="15.1 问题的动机（problem motivation）"></a><span id="15.1">15.1 问题的动机（problem motivation）</span></h3><p>从给定无标签的数据集，对数据建模 $p(x)$，对于新数据，如果 $p(x{test})＜\epsilon$ ，就将它标记为 anomaly。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/154.jpg'  width="80%" height="80%"/ loading="lazy">

<p>应用举例：</p>
<ul>
<li>网站欺骗检测。$x^{(i)}$ 是用户 $i$ 的行为，包含如登录次数、点击速度等信息；对数据建模得到 $p(x)$；对 $p(x{test})＜\epsilon$ 的 anomaly 的用户进行身份验证，或开启防御动作。</li>
<li>工业生产领域。如找到异常的机器。$x^{(i)}$ 是计算机 $i$ 的状态，包含如内存占用、CPU占用等信息；对数据建模得到 $p(x)$；对 $p(x{test})＜\epsilon$ 的 anomaly 的计算机进行监视，防止异常出现。</li>
</ul>
<h3 id="15-2-高斯分布（gaussian-distribution）"><a href="#15-2-高斯分布（gaussian-distribution）" class="headerlink" title="15.2 高斯分布（gaussian distribution）"></a><span id="15.2">15.2 高斯分布（gaussian distribution）</span></h3><h4 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h4><p>高斯分布也叫正态分布 $x\sim N(\mu,\sigma^2)$，$\mu$ 是中心值， $\sigma$ 是标准差（$\sigma^2$是方差）。</p>
<p>公式：</p>
<div>
$$
p(x;\mu,\sigma^2)=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x-\mu)^2}{2\sigma^2})
$$
</div>

<p>$\sigma$ 越小，图像越窄；无论参数如何变，图像的积分一定是1 。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/155.jpg'  width="80%" height="80%"/ loading="lazy">



<h4 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h4><p>假设 $x^{(i)}$ 符合高斯分布，但不知道 $\mu$ 和 $\sigma$ 的值。</p>
<ul>
<li>$\mu&#x3D;\frac{1}{m}\sum^m_{i&#x3D;1}x^{(i)}$，均值</li>
<li>$\sigma^2&#x3D;\frac{1}{m}\sum^m_{i&#x3D;1}(x^{(i)}-\mu)^2$，方差，也是对 $\mu$ 和 $\sigma^2$ 的极大似然估计</li>
</ul>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/156.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="15-3-异常检测算法（algorithm）"><a href="#15-3-异常检测算法（algorithm）" class="headerlink" title="15.3 异常检测算法（algorithm）"></a><span id="15.3">15.3 异常检测算法（algorithm）</span></h3><p>每个特征都随机取值，都服从一个高斯分布，等同于一个 $x_1$ 到 $x_n$ 的<strong>独立同分布</strong>。</p>
<div>
$$
p(x) = \prod^n_{j=1}p(x_j;\mu_j,\sigma_j^2)
$$
</div>


<p>异常检测算法总览：</p>
<p>先选一些符合数据分布特征的例子；根据这个数据集训练高斯分布的参数；进行估计。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/157.jpg'  width="80%" height="80%"/ loading="lazy">



<p>独立同分布相乘的直观理解：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/158.jpg'  width="80%" height="80%"/ loading="lazy">

<p>粉色是 anomaly 区域。</p>
<h3 id="15-4-开发和评价一个异常检测系统（developing-and-evaluating-an-anomaly-detection-system）"><a href="#15-4-开发和评价一个异常检测系统（developing-and-evaluating-an-anomaly-detection-system）" class="headerlink" title="15.4 开发和评价一个异常检测系统（developing and evaluating an anomaly detection system）"></a><span id="15.4">15.4 开发和评价一个异常检测系统（developing and evaluating an anomaly detection system）</span></h3><p><em>如何开发一个异常检测的应用来解决实际问题；如何评估一个异常检测算法。</em></p>
<p>之前讲到了用实数评估的好处。如果在异常检测算法也有这样的实数是比较好的。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/159.jpg'  width="80%" height="80%"/ loading="lazy">

<p>训练集是non-anomalous的，在交叉验证集、测试集中，假设是有标签的并且含有anomaly数据（y&#x3D;1代表anomaly）。图中展示了两种可行的划分方法（第二种把同样的数据同时用在交叉验证集和测试集是不推荐的）：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/160.jpg'  width="80%" height="80%"/ loading="lazy">



<p>异常检测算法的评估：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/161.jpg'  width="80%" height="80%"/ loading="lazy">

<p>首先在<strong>训练集</strong>上拟合函数 $p(x)$。</p>
<p>因为数据很倾斜（y&#x3D;1的情况很少），使用这些指标来评估：真&#x2F;假阳&#x2F;阴性，查准率和查全率，F1分。</p>
<p>可以在<strong>交叉验证集</strong>上尝试多个 $\epsilon$ 的值，并选择让F1分最高的那个，或在其他方面有良好表现的那个。</p>
<p><strong>交叉验证集的作用就是可以尝试不同的特征组合、参数值，来选择最佳的配置。</strong></p>
<p>得到了配置，就在<strong>测试集</strong>上进行最终的评估。</p>
<h3 id="15-5-异常检测与监督学习对比（anomaly-detection-vs-supervised-learning）"><a href="#15-5-异常检测与监督学习对比（anomaly-detection-vs-supervised-learning）" class="headerlink" title="15.5 异常检测与监督学习对比（anomaly detection vs. supervised learning）"></a><span id="15.5">15.5 异常检测与监督学习对比（anomaly detection vs. supervised learning）</span></h3><p><em>在上一节，我们使用了带标签的数据集来评估异常检测算法，这与监督学习有什么异同？为什么不用逻辑回归或神经网络来预测 y&#x3D;0 或 y&#x3D;1？分别在什么情况下使用两者？</em></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/162.jpg'  width="80%" height="80%"/ loading="lazy">

<p>异常检测中，<strong>有很少的正样本和很多的负样本</strong>，当在估计 $p(x)$ 的值，拟合所有高斯参数的过程中，我们只需要负样本就可以了。所以如果有大量的负样本，仍然可以拟合出很好的 $p(x)$。</p>
<p>异常检测中，有<strong>很多种类的正样本难以观测</strong>（比如有不同的原因导致发动机宕机）。如果只有很少的正样本，<strong>很难充分学习到正样本的种类是什么</strong>；并且，未出现的异常也很难被预测到。所以，放弃对正样本建模，只对负样本建模。</p>
<p>监督学习中，在正常范围内<strong>有足够的正、负样本</strong>。监督学习算法查看大量正负样本，并且能够进行种类的区分。</p>
<p>应用对比上，区别还是在数据集中<strong>正样本的数量</strong>大小。如果给异常检测的正样本收集了足够多的数据，就可以用监督学习算法来预测。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/163.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="15-6-选择特征（choosing-what-features-to-use）"><a href="#15-6-选择特征（choosing-what-features-to-use）" class="headerlink" title="15.6 选择特征（choosing what features to use）"></a><span id="15.6">15.6 选择特征（choosing what features to use）</span></h3><p><em>选择用什么特征来实现异常检测算法。</em></p>
<h4 id="如何调整特征分布"><a href="#如何调整特征分布" class="headerlink" title="如何调整特征分布"></a>如何调整特征分布</h4><p>特征选择的原则：最好<strong>让数据更接近高斯分布</strong>。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/164.jpg'  width="80%" height="80%"/ loading="lazy">



<h4 id="如何选择特征"><a href="#如何选择特征" class="headerlink" title="如何选择特征"></a>如何选择特征</h4><p>跟监督学习类似，先训练一个算法，在交叉验证集上人工查看预测出错的部分，并考虑能否找到一些其他的特征来表达这些判断出错的样本的特性。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/165.jpg'  width="80%" height="80%"/ loading="lazy">

<p>如图，只用 $x_1$ 作为特征，发现了异常点。再给数据建模添加特征 $x_2$ 后，就发现异常产生的原因了。</p>
<p>举例：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/166.jpg'  width="80%" height="80%"/ loading="lazy">

<p>CPU负载和网络负载在有些时候是线性的，也有些时候CPU负载高而网络负载低（如本机死循环）。添加了特征 $x_5$ 或 $x_6$ ，就能捕捉这种情况了。</p>
<h3 id="15-7-多元高斯分布-（multivariate-gaussian-distribution）"><a href="#15-7-多元高斯分布-（multivariate-gaussian-distribution）" class="headerlink" title="15.7 多元高斯分布*（multivariate gaussian distribution）"></a><span id="15.7">15.7 多元高斯分布*（multivariate gaussian distribution）</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/167.jpg'  width="80%" height="80%"/ loading="lazy">

<p>绿点离样本分布有距离，应该被判断为anomaly，但异常检测算法计算 $p(x^{(i)})$ ，看上去检测不出来这个异常。异常检测算法学习到的是粉色范围，而不是蓝色范围。</p>
<p>为了解决这个问题，使用多元高斯分布。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/168.jpg'  width="80%" height="80%"/ loading="lazy">

<p>$\Sigma\in \R^{n\times n}$ 是协方差矩阵，参见 <a href="#14.4">14.4PCA算法的协方差矩阵</a>。PCA第一步是均质归一化，就不用减去平均值了。</p>
<p>使用这个矩阵一次算出所有特征的概率 $p(x)$。公式：</p>
<div>
$$
p(x;\mu,\Sigma)=\frac{1}{(2\pi)^\frac{n}{2}|\Sigma|^\frac{1}{2}}exp(-\frac{1}{2}(x-\mu)^T\epsilon^{-1}(x-\mu))
$$
</div>


<p>增大 $\Sigma$ 的某个对角线值（增大某个特征分布的方差），对应x下降得更缓慢；减小 $\Sigma$  的某个对角线值（减小某个特征分布的方差），对应x下降得更缓慢。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/169.jpg'  width="80%" height="80%"/ loading="lazy">

<p>通过多元高斯分布，可以描述斜着的样本分布.越接近1，越跟横轴长度相似：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/170.jpg'  width="80%" height="80%"/ loading="lazy">

<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/171.jpg'  width="80%" height="80%"/ loading="lazy">

<p>也可以改变 $\mu$ 的值，来改变山顶的位置：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/172.jpg'  width="80%" height="80%"/ loading="lazy">



<h3 id="15-8-使用多元高斯分布进行异常检测-（anomaly-detection-using-the-multivariate-gaussian-distribution）"><a href="#15-8-使用多元高斯分布进行异常检测-（anomaly-detection-using-the-multivariate-gaussian-distribution）" class="headerlink" title="15.8 使用多元高斯分布进行异常检测*（anomaly detection using the multivariate gaussian distribution）"></a><span id="15.8">15.8 使用多元高斯分布进行异常检测*（anomaly detection using the multivariate gaussian distribution）</span></h3><h4 id="步骤和公式"><a href="#步骤和公式" class="headerlink" title="步骤和公式"></a>步骤和公式</h4><p>从数据集得到多元高斯分布的参数 $\mu$ 和 $\Sigma$：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/173.jpg'  width="80%" height="80%"/ loading="lazy">

<p>计算 $p(x)$，得到椭圆形的分布估计：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/174.jpg'  width="80%" height="80%"/ loading="lazy">



<h4 id="多元高斯分布模型和原始模型的区别"><a href="#多元高斯分布模型和原始模型的区别" class="headerlink" title="多元高斯分布模型和原始模型的区别"></a>多元高斯分布模型和原始模型的区别</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/175.jpg'  width="80%" height="80%"/ loading="lazy">

<p>原始模型不包含特征间的关系。特征的分布如果是独立的，概率分布函数就可以拆开相乘。这种拆开乘的原始模型，实际上就是某种特殊情况下（<strong>特征间不相关，即$\Sigma$ 的非主对角线都是0</strong>）的多元高斯分布。此时分布图象关于x，y轴是“正”的。</p>
<p>多元高斯模型的 $\Sigma$ <strong>非主对角线不为0，也就是特征间有相关</strong>，不能写成拆开相乘的形式。这时的<strong>分布图象是“斜”的</strong>。</p>
<p>如何在两个模型之间做选择：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/176.jpg'  width="80%" height="80%"/ loading="lazy">

<p>原始模型：</p>
<ul>
<li>手动组合异常，来捕捉异常样本（如CPU负荷低网络负荷高，需要创建新的特征，见<a href="#15.6">15.6</a>）</li>
<li>计算简单，可以计算巨大的特征数量</li>
<li>参数不多训练容易，既使数据样本很少，也能拟合出好模型</li>
</ul>
<p>多于高斯模型：</p>
<ul>
<li><p>可以自动捕捉特征间的关系</p>
</li>
<li><p>有 $\Sigma^T$ 操作，计算要求高 </p>
</li>
<li><p>必须 $m&gt;n$ ，即样本数量多于特征数量，来保证 $\Sigma$ 可逆；$\Sigma\in\R^{n\times n}$ 的参数很多，实践上最好 $m&gt;&gt;n$</p>
</li>
</ul>
<p>多元高斯分布 $\Sigma$ 不可逆的原因：</p>
<ul>
<li>不满足 $m&gt;n$</li>
<li>有线性相关的特征，造成冗余</li>
</ul>
<hr>
<h2 id="第十六章-推荐系统-Recommender-Systems）"><a href="#第十六章-推荐系统-Recommender-Systems）" class="headerlink" title="第十六章 推荐系统(Recommender Systems）"></a>第十六章 推荐系统(Recommender Systems）</h2><p>推荐系统是机器学习的一个重要应用。推荐系统的性能提升在学界仅占很小的讨论份额，但在企业里是很重要的。</p>
<p>特征学习是机器学习中很重要的思想。对于某些问题，一些算法可以自动学习一系列的特征，在有些环境下我们可以<strong>编写一个算法来学习使用哪些特征</strong>，推荐系统就是一个例子。通过推荐系统，可以了解一些特征学习的思想。</p>
<h3 id="16-1-问题规划（problem-formulation）"><a href="#16-1-问题规划（problem-formulation）" class="headerlink" title="16.1 问题规划（problem formulation）"></a><span id="16.1">16.1 问题规划（problem formulation）</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/177.jpg'  width="80%" height="80%"/ loading="lazy">

<ul>
<li><p>$n_u$：user 的数量</p>
</li>
<li><p>$n_m$：movie 的数量</p>
</li>
<li><p>$r(i, j)$：user i 是否给 movie j 打过分</p>
</li>
<li><p>$y(i, j)$：user i 给 movie j 打了几分（$r(i, j)&#x3D;1$ 时有定义）</p>
</li>
</ul>
<p>推荐系统就是开发一个算法，能够为我们填补这些缺失值。然后在用户还没看过的电影中，预测用户喜欢的电影，并推荐给该用户。</p>
<h3 id="16-2-基于内容的推荐算法（content-based-recommendations）"><a href="#16-2-基于内容的推荐算法（content-based-recommendations）" class="headerlink" title="16.2 基于内容的推荐算法（content-based recommendations）"></a><span id="16.2">16.2 基于内容的推荐算法（content-based recommendations）</span></h3><p>基于内容的意思是：我们假设已有电影内容的特征向量 $x^{(i)}$（描述电影类型）。</p>
<p>基于内容的推荐算法就相当于线性回归：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/178.jpg'  width="80%" height="80%"/ loading="lazy">

<p>每一部电影有一个题材向量 $x$，$x_1$ 评价电影的爱情要素，$x_2$ 评价电影的动作要素，$x_3$ 是偏置项1。</p>
<p>每一个用户 $j$ 有一个评分向量 $\theta^{(j)}\in \R^{(n+1)}$。根据该用户的过往评分拟合出这个向量。</p>
<p>对于新电影，用 $(\theta^{(j)} )^T x^{(i)}$ 预测用户 $j$ 对电影 $i$ 的评分。</p>
<p>更普遍的线性回归过程：为了简化表达式，将评分过的电影数量 $m^{(j)}$ 去掉。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/179.jpg'  width="80%" height="80%"/ loading="lazy">

<p>线性回归的优化目标：<strong>所求是每一个用户的喜好</strong> $\theta^{(j)}$。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/180.jpg'  width="80%" height="80%"/ loading="lazy">

<p>梯度下降：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/181.jpg'  width="80%" height="80%"/ loading="lazy">



<p>对于许多电影来说，我们并没有内容的特征向量 $x^{(i)}$，下节将介绍不是基于内容的推荐系统算法。</p>
<h3 id="16-3-协同过滤（collaborative-filtering）"><a href="#16-3-协同过滤（collaborative-filtering）" class="headerlink" title="16.3 协同过滤（collaborative filtering）"></a><span id="16.3">16.3 协同过滤（collaborative filtering）</span></h3><p>基于内容的推荐系统是我们已经拥有了内容向量（如一个电影拥有多少爱情元素，拥有多少动作元素），但实际上我们<strong>很难得到这个内容向量</strong>。 并且，我们通常需要除了爱情、动作之外的其他特征，<strong>如何得到这些新特征</strong>？</p>
<p>协同过滤算法有一个很有趣的特性：特征学习。这种算法能够自行学习所要使用的特征。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/182.jpg'  width="80%" height="80%"/ loading="lazy">

<p>我们不知道内容向量，但每个用户告诉了我们对每种电影的喜爱程度 $\theta^{(j)}$。对于电影 $x^{(1)}$，我们知道 $\theta^{(1)},\theta^{(2)}$ 喜欢并且 $\theta^{(3)},\theta^{(4)}$ 不喜欢，那么可以推断 $x^{(1)}$ 是爱情片而不是动作片，并可以根据 $(\theta^{(j)})^T x^{(1)}\approx r(1, j)$ 计算出 $x^{(1)}$ 的具体值。</p>
<p><strong>所求是每一部电影的内容向量</strong> $x^{(i)}$：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/183.jpg'  width="80%" height="80%"/ loading="lazy">



<p>这节和上节的算法可以形成协同过滤的迭代过程：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/184.jpg'  width="80%" height="80%"/ loading="lazy">

<p>从一个初始用户喜爱向量 $\theta$ 开始，可以不断进行梯度优化，得到更准确的用户喜好 $\theta$、电影类型 $x$，并且得到好的推荐系统。</p>
<h3 id="16-4-协同过滤算法（collaborative-filtering-algorithm）"><a href="#16-4-协同过滤算法（collaborative-filtering-algorithm）" class="headerlink" title="16.4 协同过滤算法（collaborative filtering algorithm）"></a><span id="16.4">16.4 协同过滤算法（collaborative filtering algorithm）</span></h3><p>在前两节，我们学习了：</p>
<ul>
<li>给出电影的特征，可以用来学习用户的参数 $\theta$</li>
<li>给出用户的参数，可以用来学习电影的特征 $x$</li>
</ul>
<p>有一种更高效的算法，我们不需要不停的交替计算 $x$ 和 $\theta$，而是能同时计算 $x$ 和 $\theta$。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/185.png'  width="80%" height="80%"/ loading="lazy">

<p>取消了偏置项，即 $x_0,\theta_0$。因为算法要学习很多的特征，如果需要一个特征永远为1，可以选择靠自己去获得这个参数，比如把 $x_1$ 学习为1。让 $x$ 和 $\theta$ 自己学习线性关系，不需要人为加截距项。</p>
<p>协同过滤算法：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/186.png'  width="80%" height="80%"/ loading="lazy">

<ul>
<li>用小的随机数初始化，有点像神经网络的初始化</li>
<li>进行梯度下降，最小化 $J$</li>
<li>用 $\theta^Tx$ 进行预测</li>
</ul>
<h3 id="16-5-向量化：低秩矩阵分解（vectorization-low-rank-matrix-factorization）"><a href="#16-5-向量化：低秩矩阵分解（vectorization-low-rank-matrix-factorization）" class="headerlink" title="16.5 向量化：低秩矩阵分解（vectorization : low rank matrix factorization）"></a><span id="16.5">16.5 向量化：低秩矩阵分解（vectorization : low rank matrix factorization）</span></h3><p>低秩矩阵分解就是协同过滤的向量化求解过程：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/187.png'  width="80%" height="80%"/ loading="lazy">

<p>通过电影内容向量 $x$ 可以度量电影之间的相关性：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/188.png'  width="80%" height="80%"/ loading="lazy">



<h3 id="16-6-实现细节：均值归一化（implementational-detail-mean-normalization）"><a href="#16-6-实现细节：均值归一化（implementational-detail-mean-normalization）" class="headerlink" title="16.6 实现细节：均值归一化（implementational detail : mean normalization）"></a><span id="16.6">16.6 实现细节：均值归一化（implementational detail : mean normalization）</span></h3><p>如果一个用户没有给任何的电影评分，那在梯度下降最小化 $J$ 的过程中，会学习到 $\theta^{(j)} &#x3D; 0$。如果用 $\theta^Tx$ 做预测，会将所有的电影分数预测为0分，并且不会给用户做任何推荐。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/189.png'  width="80%" height="80%"/ loading="lazy">



<p>均值归一化让我们解决这类问题。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/190.png'  width="80%" height="80%"/ loading="lazy">

<p>给评分矩阵 $Y$ 减去评分均值 $\mu$，然后将新矩阵进行协同过滤，在预测阶段再把 $\mu$ 加回到预测的评分上。</p>
<p>对于没有评分的用户，会预测为平均分，推荐给他大家都觉得好的电影。</p>
<p>对于没有人评分的电影，不推荐给任何用户。</p>
<hr>
<h2 id="第十七章-大规模机器学习-Large-Scale-Machine-Learning）"><a href="#第十七章-大规模机器学习-Large-Scale-Machine-Learning）" class="headerlink" title="第十七章 大规模机器学习(Large Scale Machine Learning）"></a>第十七章 大规模机器学习(Large Scale Machine Learning）</h2><p>处理大数据集的算法。</p>
<h3 id="17-1-大型数据集的学习（learning-with-large-datasets）"><a href="#17-1-大型数据集的学习（learning-with-large-datasets）" class="headerlink" title="17.1 大型数据集的学习（learning with large datasets）"></a><span id="17.1">17.1 大型数据集的学习（learning with large datasets）</span></h3><p>如果数据集 m&#x3D;1亿，梯度下降的每一步都要对 m&#x3D;1亿 项求和，计算代价太大了。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/191.png'  width="80%" height="80%"/ loading="lazy">

<p>在高偏差的情况下，让数据集增大效果不好；在高方差的情况下，增大数据集一般是有效的。</p>
<p>详见 <a href="#10.6">10.6学习曲线</a></p>
<h3 id="17-2-随机梯度下降（stochastic-gradient-descent）"><a href="#17-2-随机梯度下降（stochastic-gradient-descent）" class="headerlink" title="17.2 随机梯度下降（stochastic gradient descent）"></a><span id="17.2">17.2 随机梯度下降（stochastic gradient descent）</span></h3><p>batch gradient descent：批量梯度下降，每次要同时考虑所有的训练样本。</p>
<p>如果数据集很大，对计算时间、内存容量都有很高的要求。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/192.png'  width="80%" height="80%"/ loading="lazy">



<p>stochastic gradient descent：随机梯度下降，先打乱数据集，然后用单个数据样本进行梯度下降。内层循环遍历所有数据样本，外层循环控制遍历次数，一般取1~10。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/193.png'  width="80%" height="80%"/ loading="lazy">



<p>批量梯度下降每次迭代取平均的梯度，直接向最优点收敛（红线）；随机梯度下降	每一次迭代都会更快，每次只需保证能拟合某一个训练样本就可以了，每一步不一定都向最优点收敛，但总体上也能到达最优点（粉线）。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/194.png'  width="80%" height="80%"/ loading="lazy">



<h3 id="17-3-小批量梯度下降（mini-batch-gradient-descent）"><a href="#17-3-小批量梯度下降（mini-batch-gradient-descent）" class="headerlink" title="17.3 小批量梯度下降（mini-batch gradient descent）"></a><span id="17.3">17.3 小批量梯度下降（mini-batch gradient descent）</span></h3><p>批量梯度下降迭代慢、收敛快；随机梯度下降迭代快、收敛慢。小批量梯度下降是两者的折中方案。</p>
<p>一次取 b 个样本进行小批量梯度下降，b 一般取 2~100。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/195.png'  width="80%" height="80%"/ loading="lazy">



<p>小批量梯度下降可能会比随机梯度下降算法更好，仅当：有一个好的向量化方法。在这种情况下，对一批 b 个样本的偏导求和能以更向量化的方式执行，这将使我们在 b 个样本中实现部分并行计算（同时计算 b 个）。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/196.png'  width="80%" height="80%"/ loading="lazy">



<h3 id="17-4-随机梯度下降收敛（stochastic-gradient-descent-convergence）"><a href="#17-4-随机梯度下降收敛（stochastic-gradient-descent-convergence）" class="headerlink" title="17.4 随机梯度下降收敛（stochastic gradient descent convergence）"></a><span id="17.4">17.4 随机梯度下降收敛（stochastic gradient descent convergence）</span></h3><p><em>在运行随机梯度下降算法时，如何确保调试过程已经完成，并且已经收敛到合适的位置呢？怎样调整随机梯度下降种学习速率 $\alpha$ 的值？</em></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/197.png'  width="80%" height="80%"/ loading="lazy">

<p>在批量梯度下降中，通过绘制 $J(\theta)$ 的图像来判断收敛。原因是批量梯度下降的每一次迭代，代价函数都是减小的。需要在算法运行过程中扫描一遍整个数据集来计算当前的 $J(\theta)$ ，所以数据集很大的时候也不好用。</p>
<p>随机梯度下降每次只考虑一个单独的样本，每次让算法前进一点，就不需要停下算法来计算 $J(\theta)$ 了。只需关注单个样本 $(x^{(i)},y^{(i)})$ ，在用该样本更新 $\theta$ 之前，计算 $cost(\theta, (x^{(i)},y^{(i)}))$ 。并且在一定量的数据样本的迭代后，打印 $cost$ 的平均值。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/198.png'  width="80%" height="80%"/ loading="lazy">

<p>图左上：学习率大和小。学习率小的收敛结果可能更好。</p>
<p>图右上：计算 $cost$ 均值的数据量越大，曲线越平滑。缺点是求均值的数据量大，得到的反馈有延迟。</p>
<p>图左下：少的数据量求平均，看上去没有在学习收敛（蓝线）；但大的数据量求均值，可以看出函数实际上是在收敛的过程中的（红线）。如果大学习量求均值，函数也不收敛，就是算法出了问题（粉线）。</p>
<p>图右下：$cost$ 在增加，函数发散了。需要用更小的学习率 $\alpha$。	</p>
<p>关于学习率：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/199.png'  width="80%" height="80%"/ loading="lazy">

<p>随机梯度下降的结果是在最小值附近震荡，如果想让随机梯度下降更好地收敛到全局最小值（震荡的幅度小），可以让学习率 $\alpha$ 随时间变化逐渐减小。但同时，也会带来新的确定参数的工作。</p>
<h3 id="17-5-在线学习（online-learning）"><a href="#17-5-在线学习（online-learning）" class="headerlink" title="17.5 在线学习（online learning）"></a><span id="17.5">17.5 在线学习（online learning）</span></h3><p><em>我们有连续一波数据或连续的数据流，想要用算法来学习。</em></p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/200.png'  width="80%" height="80%"/ loading="lazy">

<p>跟随机梯度下降很相似，区别是：在线学习不使用固定的数据样本 $(x^{(i)},y^{(i)})$ ，而是根据目前的数据流  $(x, y)$ 来训练模型。这要求数据流比较多，这样就不用重复学习同样的样本了。</p>
<p>还有一个好处，就是这样可以适应用户喜好随着时代的变化。</p>
<p>另一个应用场景：预测点击率，并进行推送。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/201.png'  width="80%" height="80%"/ loading="lazy">



<h3 id="17-6-映射化简和数据并行（map-reduce-and-data-parallelism）"><a href="#17-6-映射化简和数据并行（map-reduce-and-data-parallelism）" class="headerlink" title="17.6 映射化简和数据并行（map-reduce and data parallelism）"></a><span id="17.6">17.6 映射化简和数据并行（map-reduce and data parallelism）</span></h3><p><em>前面的梯度下降算法都能在单个计算机上运行。但有时候可能数据太多了，不想把所有数据都在一台电脑上跑一遍。</em></p>
<p>map-reduce：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/203.png'  width="80%" height="80%"/ loading="lazy">

<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/202.png'  width="80%" height="80%"/ loading="lazy">

<p>批量梯度下降：</p>
<ul>
<li>在单个主机上计算 $\theta_j :&#x3D;\theta_j-\alpha\frac{1}{400}\sum_{i&#x3D;1}^{400}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$</li>
</ul>
<p>map-reduce：</p>
<ul>
<li>将数据集分成几部分，在不同的主机上计算 $temp_j^{(t)}&#x3D;\sum_{}^{}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$</li>
<li>然后在整合服务器上计算 $\theta_j :&#x3D;\theta_j-\alpha\frac{1}{400}\sum temp_j^{(t)}$。</li>
</ul>
<p>实际上，很多学习算法都可以表示成对训练集函数的求和，而在大数据集上运行所消耗的运算量就在于需要对非常大的训练集进行求和。所以<strong>只要学习算法可以表示为对训练集的求和，或者学习算法的主要工作可以表示成对训练集的求和，那么就可以使用 map-reduce 将学习算法的适用范围扩大到非常大的数据集。</strong></p>
<p>举例：如果使用高级优化函数来训练logistic算法，需要计算两个重要的量：一个是对于高级学习算法，需要提供一个过程来计算优化目标的代价函数 $J_{train}(\theta)$ ，第二个是计算偏导数 $\frac{\partial}{\partial \theta_j}J_{train}(\theta)$。将这两个求和过程分散给多个主机，然后把结果整合起来，就获得总的损失和总的偏导项，接着将这两个值交给高级优化算法。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/204.png'  width="80%" height="80%"/ loading="lazy">



<p>也有时候可以在单个电脑上进行 map-reduce。有的电脑又多个CPU，CPU又有多个核心。如果有一个很大的数据集，可以在单机上分给不同的核心来计算。</p>
<p>也有些线性代数库，可以自动进行多核运算。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/205.png'  width="80%" height="80%"/ loading="lazy">





<hr>
<h2 id="第十八章-应用实例：图片文字识别-Application-example-Photo-OCR）"><a href="#第十八章-应用实例：图片文字识别-Application-example-Photo-OCR）" class="headerlink" title="第十八章 应用实例：图片文字识别(Application example : Photo OCR）"></a>第十八章 应用实例：图片文字识别(Application example : Photo OCR）</h2><p>一个复杂的机器学习系统是如何组织起来的。</p>
<p>机器学习pipeline的相关知识，以及如何分配资源。</p>
<p>机器学习中一些有用的想法和概念，如：如何将机器学习运用到计算机视觉问题中；人工数据合成的概念。</p>
<h3 id="18-1-问题描述和流程（problem-description-and-pipeline）"><a href="#18-1-问题描述和流程（problem-description-and-pipeline）" class="headerlink" title="18.1 问题描述和流程（problem description and pipeline）"></a><span id="18.1">18.1 问题描述和流程（problem description and pipeline）</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/206.png'  width="80%" height="80%"/ loading="lazy">

<p>pipeline：</p>
<ol>
<li>找出有文字的图像区域</li>
<li>进行字母分离</li>
<li>分类器识别字母</li>
</ol>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/207.png'  width="80%" height="80%"/ loading="lazy">



<p>在机器学习实践中，很重要的一步就是设计机器学习的pipeline，如何将整个问题分为一系列不同的模块。</p>
<h3 id="18-2-滑动窗口（sliding-windows）"><a href="#18-2-滑动窗口（sliding-windows）" class="headerlink" title="18.2 滑动窗口（sliding windows）"></a><span id="18.2">18.2 滑动窗口（sliding windows）</span></h3><h4 id="pipeline第一步：检测文字区域"><a href="#pipeline第一步：检测文字区域" class="headerlink" title="pipeline第一步：检测文字区域"></a>pipeline第一步：检测文字区域</h4><p><strong>行人检测任务：</strong></p>
<p>训练阶段，矩形的长宽比例比较固定。可以构建监督学习模型，根据带有标签的数据集，学习预测是否含有行人。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/208.png'  width="80%" height="80%"/ loading="lazy">

<p>预测阶段，使用滑动窗口：建立不同尺寸的滑动窗口，按照一定的步长，取一系列图像，判断是否含有行人。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/209.png'  width="80%" height="80%"/ loading="lazy">



<p><strong>文本检测任务：</strong></p>
<p>模型训练阶段，也可以训练类似的监督学习模型：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/210.png'  width="80%" height="80%"/ loading="lazy">

<p>预测阶段：使用小的滑动窗口，预测图中各个区域有文字的概率（越亮代表有文字的可能性大）然后进行放大算子，将白色区域扩大。并对长宽比进行筛选。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/211.png'  width="80%" height="80%"/ loading="lazy">



<h4 id="pipeline第二步：字母分割"><a href="#pipeline第二步：字母分割" class="headerlink" title="pipeline第二步：字母分割"></a>pipeline第二步：字母分割</h4><p>训练监督学习模型，识别<strong>字母分割的部分</strong></p>
<p>在第一步检测到文字的区域进行滑动窗口，预测在哪里进行了字母的分割。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/212.png'  width="80%" height="80%"/ loading="lazy">



<h4 id="pipeline第三步：字母识别"><a href="#pipeline第三步：字母识别" class="headerlink" title="pipeline第三步：字母识别"></a>pipeline第三步：字母识别</h4><p>监督学习多分类问题，不赘述。</p>
<h3 id="18-3-获取大量数据和人工数据合成（getting-lots-of-data-artificial-data-synthesis）"><a href="#18-3-获取大量数据和人工数据合成（getting-lots-of-data-artificial-data-synthesis）" class="headerlink" title="18.3 获取大量数据和人工数据合成（getting lots of data : artificial data synthesis）"></a><span id="18.3">18.3 获取大量数据和人工数据合成（getting lots of data : artificial data synthesis）</span></h3><p>一个得到高性能机器学习系统的方法：做一个低偏差的机器学习算法，并且使用庞大的训练集去训练它。</p>
<p>通过人工数据合成，得到大量的训练数据。</p>
<h4 id="其一：从零开始产生数据集"><a href="#其一：从零开始产生数据集" class="headerlink" title="其一：从零开始产生数据集"></a>其一：从零开始产生数据集</h4><p>用不同的字体生成字符，然后粘贴到不同的背景下，应用模糊算子、仿射变换、缩放旋转等操作，制作成为新的训练样本。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/213.png'  width="80%" height="80%"/ loading="lazy">

<p>左边是真实数据集，右边是人造数据集。</p>
<h4 id="从已有数据扩充数据集"><a href="#从已有数据扩充数据集" class="headerlink" title="从已有数据扩充数据集"></a>从已有数据扩充数据集</h4><p>将已有数据样本进行扭曲等操作，扩充数据集。在语音识别中，也可以认为给“干净”的音频加上各种背景噪声，扩充数据集。</p>
<p>注意，要添加“有意义”的噪声，即在真实异常状况下会出现的噪声。添加纯净的随机噪声往往是没用的。比如最好改变文字的形状，只加高斯噪声改变图片某处的亮度没什么用。</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/214.png'  width="80%" height="80%"/ loading="lazy">



<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/215.png'  width="80%" height="80%"/ loading="lazy">

<ul>
<li>扩充数据集有用吗？在扩充数据集之前，首先要保证我们的分类器偏差较低。这样，更多的数据才会起作用。标准的做法是绘制学习曲线，确保这是<strong>低偏差、高方差</strong>的分类器。如果分类器的偏差太高，可以尝试增加特征的数量，或者增加神经网络隐藏神经元的数量，直到偏差降低。然后再花精力生成人工训练集。</li>
<li>获得10倍于当前数据集的数据，需要花费多少努力？其实扩充数据集没有想象中难。<ul>
<li>本节讲的，人工生成</li>
<li>收集数据或打标签</li>
<li>众包</li>
</ul>
</li>
</ul>
<h3 id="18-4-上限分析：劲往何处使（ceiling-analysis-what-part-of-the-pipeline-to-work-on-next）"><a href="#18-4-上限分析：劲往何处使（ceiling-analysis-what-part-of-the-pipeline-to-work-on-next）" class="headerlink" title="18.4 上限分析：劲往何处使（ceiling analysis : what part of the pipeline to work on next）"></a><span id="18.4">18.4 上限分析：劲往何处使（ceiling analysis : what part of the pipeline to work on next）</span></h3><p>工作流中的哪一部分是最值得花时间去研究的？</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/216.png'  width="80%" height="80%"/ loading="lazy">

<p>对学习系统使用一个数值评价度量：准确度accuracy。先看整个系统的表现（72%），然后人工按顺序给出每个模块的正确答案，然后看整个系统的准确度表现提升。这样，我们可以看出各个模块的上升空间有多大。</p>
<p>如图，就算 character segmentation 模块到达了完美，总体性能也只能提升 1%。</p>
<p>另一个例子，身份识别的pipeline如下：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/217.png'  width="80%" height="80%"/ loading="lazy">

<p>上限分析如下：</p>
<img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/218.png'  width="80%" height="80%"/ loading="lazy">

<p>可以看到，完美的 face detection、eyes segmentation、logistic regression 会对模型有较大的改进；preprocess 对模型的改进很小。</p>
<hr>
<h2 id="第十九章-结束-Conclusion）"><a href="#第十九章-结束-Conclusion）" class="headerlink" title="第十九章 结束(Conclusion）"></a>第十九章 结束(Conclusion）</h2><h3 id="19-1-总结与致谢（summary-and-thank-you）"><a href="#19-1-总结与致谢（summary-and-thank-you）" class="headerlink" title="19.1 总结与致谢（summary and thank you）"></a><span id="19.1">19.1 总结与致谢（summary and thank you）</span></h3><img src='https://cdn.jsdelivr.net/gh/ACBGZM/MyPostImage@master/ml-notes-img/ml2014ang/219.png'  width="80%" height="80%"/ loading="lazy"></div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>miu</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://acbgzm.github.io/2021/03/25/ml2014ang/" title="machine learning - andrew ng">http://acbgzm.github.io/2021/03/25/ml2014ang/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/05/27/dlang/" rel="prev" title="dl &amp; ai - andrew ng"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">dl &amp; ai - andrew ng</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/14/summary-2020/" rel="next" title="什么都没做的2020"><span class="post-nav-text">什么都没做的2020</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><style>.utterances {
  max-width: 100%;
}</style><script src="https://utteranc.es/client.js" repo="ACBGZM/ACBGZM.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> miu</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.9</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div class="search-result-container"></div></div></body></html>